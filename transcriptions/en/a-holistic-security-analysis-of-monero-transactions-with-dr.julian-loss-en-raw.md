# Dr. Julian Loss

_**A Holistic Security Analysis of Monero Transactions**_

[https://youtu.be/QQCmFDN9klw](https://youtu.be/QQCmFDN9klw)

---

_**Moderator:**_ Alright, so the next we've got Julian Loss.

_**Julian:**_ Can you see my screen?

_**Moderator:**_ Yep.

_**Julian:**_ Okay. Well, thank you for having me. So I'm going to keep it. Yeah. Sorry. Did you want to do an introduction, or should I just begin?

_**Moderator:**_ Oh, yeah. We've had people just begin.

I'm sorry. I'm a volunteer. I don't know too well who is who. Yeah, I'm tasked with just trying to make this go smoothly. Sorry.

_**Julian:**_ Yeah, sure, sure. I go off. But anyway, thank you.

So I'm going to be presenting a very recent work of ours called "A Holistic Security Analysis of Monero Transactions". And this is joint work with my colleague Caz Cremers and my student Benedict Wagner.

Okay, so obviously, I'm going to be talking about Monero and more specifically, I'm going to be talking about its transaction scheme, which is called RingCT. And just to give a broad picture of what I'm going to be talking about Monero, as you probably know, because this Monerotopia, is a privacy-focused currency. It has a market capitalization of about $2.8 billion, and transactions are secured by a very complex transaction system called RingCT, which is the subject of our work.

Now RingCT is made up of a bunch of components which I've listed here. Most notably, we have linkable ring signatures, commitments, range proofs, and stealth addresses. And I'm gonna be going over some of these components today, and I'm gonna be explaining how they work and how they form together to form RingCT, you know, at a very, very abstract level.

Okay, so the central question that we're trying to answer here is "Is RingCT secure?" And now if you're not from the area of provable security, then you might ask why? And the answer is, well, I mean, it's a huge cryptocurrency and it's a very, very complex system. And as far as we're concerned, there has been no security proof of the entire system that covers all aspects as a whole. There have been proofs of partial, components of the system, but there has been no analysis of the whole transaction system as a whole. And for that reason, it's actually not clear whether it has the provable security guarantees that it claims. So spoiler - it does. We found no bug in the transaction protocol, and we managed to prove it secure. So that's good, I hope. Another thing that I want to add here is that we only consider the security of transactions, but not their privacy. So, okay, with those things out of the way, let's jump right in.

Now, basically the main result of our work is that we give an abstraction and a security model for RingCT. And we managed to prove the security of RingCT within this abstraction and security model according to the two following security goals. The first one is that the adversary cannot steal any coins in Monero. And the second one is that the adversary should not be able to create any coins. And if we can prove those two things, then intuitively Monero should be a secure cryptocurrency.

Okay. So our security analysis proceeds in two steps, basically. So the first thing that we do, and I'm not going to be talking about this today, is that we modularize this very, very complex transaction system into multiple different components. And then we actually give a very detailed analysis of each of these components. Okay, and once we have all of these security definitions for these components, we put them all together and then we do a system level analysis of the security of RingCT, and it follows, of course, from the security of all of these different cryptographic components. And so what I mean by components here are, a lot of these different things that I had on my previous slide, like a special type of linkable ring signature, which I'll be getting back to later, key derivation components, commitments and so on. But I'll be talking about that in a second. Okay, so this talk will cover the system level analysis, but not the component level analysis.

Okay, so now let's have a look first at how RingCT actually works. So to begin, let's have a look at how transactions work in popular cryptocurrencies. So first we have plain transactions such as you can find in Bitcoin. And in Bitcoin a transaction basically just transfers some amount of cryptocurrency from the sender's public key, say Alice, to the recipient's public key, say Bob here.

Okay, and then on the complete other side of the spectrum we have encrypted transactions such as in Zcash, where you have a guarantee, actually provable guarantee, that you have complete anonymity within a certain set, anonymity set of users, where nobody can get any information about any of the transactions that are being transferred. So in Zcash, this would be the shielded pool, right? And of course, this gets very, very strong privacy guarantees. But as you can see in the example of Zcash, these transactions are typically a lot slower and they're more expensive. And that's why they're not being used that much, even though they exist.

And now Monero, I see it basically as falling in between these two extremes. So Monero gives very strong privacy guarantees using an approach called "mixing". So the idea is to take a bunch of transactions, mix them all together, and shuffle them around so that it's not clear who's paying how much to whom. And that anonymizes the senders and the recipients in this very complex system. And it makes it much harder to trace certain payments going from A to B.

Now, okay, let's have a closer look at the anatomy of plain transactions and then how that would translate into a Monero transaction.

So going back to this very, very simple and rudimentary example of Bitcoin, here a transaction would look as follows. So if say Alice wants to transfer two Bitcoins to Bob, then what she would do is she creates a transaction where she identifies herself as the sender, she identifies the amount, and she also identifies as the receiver Bob, and then she signs this transaction with her secret key which can be verified upon anybody holding her public key. And this will transfer two Bitcoins to Bob, and then Bob can do the same thing to spend those transactions in turn.

And the idea is that each transaction that is being processed here actually contains as an input the output or the unspent output of a previous transaction. So whenever you will pay transaction to somebody, then whatever is left over, what doesn't go to that recipient will become a new unspent output that can be later spent in the next transaction. And we refer to this as the unspent transaction or UTXO model.

So now let's get a little bit closer to what Monero is doing. So here we will actually consider multi-input transactions. So before we only had a single input from Alice, but now let's say that Alice has two unspent outputs, each corresponding to one Monero or one Bitcoin, and she wants to spend both of those unspent outputs. So now a multi-input transaction would allow Alice to spend both of these unspent outputs at the same time. So in my previous example here, I used one Bitcoin for both of these, or one Monero for both of these unspent outputs, but now let's see what happens if Alice would have, say, two unspent Monero in the first unspent output and three in the second one. What would happen then is that there is one coin remaining that is not transferred over to Bob, because Bob in this transaction only gets four Moneroes, and whatever remains after that actually gets transferred into a new unspent output of Alice.

So this is my running example here. Again here Alice will use the same amount of currency in both of her inputs and in as you will see, it's important to add references to each of these inputs so that they can be distinguished when the transaction is built.

Okay, so now let's get to the main ideas of RingCT. So the first thing that we want to do in RingCT is we want to hide the senders. We don't want to reveal who is sending to whom. So for this, at a very, very conceptual level, we will be using primitive called "ring signatures", which I'm going to explain on the next couple of slides. The second goal that we want to have is that we want to hide the amounts of how much money is being transferred between senders and recipients. For this, we will use cryptographic commitments. And the third thing that we want to do is we want to hide who is receiving what amount from whom, and for this we will be using stealth addresses.

Okay, so let's actually look at this third component first, the stealth addresses, because I believe that this is really what sets Monero apart from a lot of other cryptocurrencies. So here is how that works. Basically, Bob, who is going to be the recipient of this stealth transaction, will have two long-term secret keys, which are just Zp elements, kv for the view key and ks for the spending key. And those corresponds to two points on the elliptic curve. And those are his public view key and his public spending key. Okay. So those are Bob's long-term keys.

Now, excuse me, if Alice would like to spend both of these unspent outputs to Bob in this transaction, then what she will do is the following. He will sample a random r from Zp, and p here is the order of the elliptic curve that we're using, and then she will generate this randomness as raising the base point of this curve to this power of r. Then she will generate an output key by taking Bob's view key and raising Bob's view key to this r, which I have just said. Then she will hash the output key, raise the base point to this hash, and multiply it with Bob's public key that her outputs are being transferred to. Now Bob can actually check whether this output is his by computing the output key on his side. And because these two operations commute in the exponent, that's basically you can think of it as a mini Diffie-Hellman key exchange, and then it can check whether this transaction is actually meant for him. Then if it is indeed meant for him, then you can later spend it by computing spending key in this fashion right here.

Okay, so now actually something else happens. So what Alice now adds to this transaction is a commitment to the amount in the transaction. So to do this, she will commit to the amount that's in this transaction, and she'll do this by computing a commitment, say a Pedersen commitment, onto with some corresponding commitment randomness that I've denoted here as cr. Okay. So. Intuitively, this commitment, we will use it, as I said, to hide the amounts of what is being transferred here, but we'll get to that only on the next slide. First, let's have a look at how we can hide the inputs using ring signatures.

Okay, so in a Monero transaction, what is going to happen is that each user is going to supply not only their inputs, but also some decoy inputs. And the intuitive reason behind this is that what we want to do is increase the anonymity set. Remember, we want to make it very difficult for somebody who is an eavesdropper, who is observing these transactions to see how much money is being sent around between senders and recipients. And for this reason, we're going to increase the anonymity set by adding some decoy inputs to every transaction. And these are the light gray transactions here in this drawing. Okay, so again, we're going to reference all of them so that they can be distinguished.

And now two problems remain, basically. So the first thing that we have to prevent is double spending. And the second thing that we have to prevent is that the sum of all the amounts that are going into this transaction are being transferred over to the recipients of this transaction have to be preserved through this intermediate layer, where we are actually committing to the inputs, and then they're going to be spent to the recipients.

So to prevent double spending, as I already said, we're going to use linkable ring signatures. So what is a linkable ring signature? First, let's have a look at what is a ring signature actually. A ring signature, very abstractly spoken, is a regular signature, basically, cryptographic signature, but it doesn't behave syntactically like a regular signature. Rather, we have a group of people, let's call them, they're called the ring, and they want to jointly generate a signature on behalf of the group. So, remember from this ring can actually generate the signature, and then it will act as a signature on behalf of this group, but nobody can tell who the member of the ring was who generated the signature. That's the functionality that a ring signature provides, so it's a certain degree of anonymity.

Now with a linkable ring signature, we have an additional feature. We can make sure that if somebody attempts to sign twice, so the same member of the ring tries to sign two different things, then there is an algorithm that we can use to efficiently link this to the same user and identify it. And this is one of the key components in the Monero CT transaction system.

So here is the first attempt of preserving the amounts in such a privacy preserving transaction. So the sender wants to show that the amounts hidden in these two points, black commitments here, the ones that are in decoy commitments, sums up to whatever is in the commitment that corresponds to the output. Okay, so what's the idea here? The idea here is that we're going to use Pedersen commitment to do this, which has a homomorphic property. And what that means is that given the two commitments to the inputs, one can efficiently check whether whatever is being committed to, sums up to the commitment that should be the sum of their inputs without actually knowing what is inside these commitments. So here is the verification equation, and that's the reason why this actually works.

Now the problem that remains here is actually privacy problem, because if we give this homomorphic functionality for the commitments, then it is actually possible to use that to identify which of these inputs are decoy inputs corresponding to basically zero coins and which are real inputs corresponding to non-zero coins. Because if I have a decoy input, then I can just try to add it to another one of these commitments homomorphically, and then you can see that the amount will be preserved, and then it's not private anymore, and it doesn't hide the amounts in these inputs. And that, of course, is exactly the reason why we want to have these commitments in the first place.

So how do we get rid of that? Well, there is a famous quote attributed to David Wheeler, which says that "All problems in computer science can be solved by another level of indirection. So I'm not sure if this is universally true, but in the specific case of Monero, it is actually true. So what we're gonna do is add exactly such a layer indirection", and this will correspond to something called pseudo outputs. So rather than outputting directly, we will have a layer of pseudo outputs and so the commitments in the pseudo outputs should now have the property that they homomorphically can sum up to the commitment in the output.

But to make sure that these cannot be linked to the amounts in the original transactions, they cannot be used to distinguish which are decoys and which are not, we will use a ring signature to spend from the inputs to these commitments. So the intuitive idea behind this is that the set of all of these commitments is basically the set of users who want to sign. And that sounds a little bit weird, because now each of these commitments also sort of can be thought of as having a public key, namely the public key that corresponds to this transaction here or to this input. And what we want to do is we want to show that there was one of these input commitments plus public keys who signed the corresponding amount that transferred to this commitment. But we don't want to show which of them it was, because that would reveal which ones are the decoy inputs and which are not. So that's the very, very high-level idea, basically to treat these inputs as users in the ring signature, very abstractly spoken.

Once we were able to do that, so to get from inputs to pseudo outputs, then we've broken this link that can be used to distinguish decoy inputs from real inputs. Because we basically add this layer of anonymity using the ring signature.

_[Ad]_

_Do you love coffee and Monero as much as we do? Consider making gratuitas.org your daily cup. Pay with Monero for premium fresh beans, and if you like what you taste, send a digital cash tip directly to the Guatemalan farmers that made it possible. Proceeds help us grow this channel. Gratuitas and Monero._

_**Julian:**_ So that only leaves one thing, which is how are the transactions verified in the system? Well, basically we're going to check for the following things. First, we're going to check whether all inputs are previous unspent outputs. Then we're going to check for whether all signatures, meaning ring signatures here, are valid. And we're also going to check that no signature links, because if a signature links, then basically that means that somebody tried to spend the same output twice in two different transactions, and that of course would be an attempt of double spending, and that's something we want to prevent. And lastly, we're going to check whether the amount of the transaction is preserved, so the amount that's being input is preserved in the output by checking this homomorphic equality here.

That was a very brief overview of how RingCT works. It's rather complicated, and I hope now you can appreciate why it's so difficult to prove the scheme secure. But now let's actually turn to our security model.

So for the security model, because many of you might not have a background in provable security, let's actually first explain what exactly the security model should capture, and how it works, and how to think about it. So in provable security, the way that we think about security, and I think I already mentioned this at the beginning of my talk, is we think of security as being formalized as a game between a challenger who proposes a scheme, in this case the Ring CT scheme, and an adversary that tries to break the security of that scheme. So the adversary basically tries to win the game by breaking whatever security property we formalize here. And the goal of our work, of course, is to formalize such a security game, which accurately captures whatever is going on in the real world, and map it to a mathematical model. And that's the intuition here.

So now that means that we have to abstract what the adversary can meaningfully do in the real world into our model. So the adversary could in our model create new honest users. So it can basically tell somebody to take up Monero, start mining some coins and behave like an honest user of the system maybe through the phishing mail, for example. Then the next thing that it can do is it can submit transactions to the system, or it can spend some transactions to other users, participate in mixed transactions, and so on and so forth. It can make honest users submit transactions by, for example, conning them into spending something. So thirdly, it can corrupt users, meaning that now it controls that user and all of their funds. And it can do so in our model at any point in time. And finally, just to add some money to the system initially, we'll also allow the adversary to create "source" coins, which basically just means that the system will be populated with some currency.

Okay, so now let's formalize the winning conditions of the adversary in this security game between our implicit challenger and whatever adversary tries to break the security.

So the first winning condition is that the adversary can steal coins from honest users, meaning that they can spend the coins of honest users without of course knowing their spending keys. The second condition is that the adversary can create coins out of thin air, which of course would also undermine the security of the honest, users because then money's worth nothing. Now for the remainder of my talk, I'm going to be focusing on this second winning condition here, so the adversary should not be able to create coins out of thin air. And let's have a look at how we formalize this.

So we'll start with having some invariant called or some variable rather called received and it's just going to be some natural number. And whenever the adversary gets some coins either from a source or from an honest user, then the amount received will be increased by that much. Secondly, we have a variable called spent. And whenever the adversary spends any coins to an honest user, then the amount spent will be increased by that much.

So the winning condition now can be phrased as "spent being greater than received". Because that means that the adversary spent some money which it did not receive and that would amount to it creating coins out of thin air. And in this case, the adversary would win.

Okay, so this is the security model and the adversary's goal. And now let's actually have a very, very brief look at how we would attempt to prove such a thing.

Okay, so if we have a look at these transactions, again remember that we have these three: layers, inputs, pseudo outputs, and outputs, and now our idea is that, you know, skipping some details here, that we want to map all of these transactions which happen over the lifetime of the entire system to a graph. And once we have this graph, we're actually going to be able to apply graph theoretic arguments that show that the adversary is not capable of spending more coins than it receives. And this is going to come down to a graph theoretic argument.

And the key difficulty of the proof really is to show that each behavior of the adversary that it can perform in this abstraction of the system can actually be mapped to a unique graph that we can later analyze. So this is actually where the cryptographic security of all of the components of the system comes in, because if those components were not secure then we couldn't map each set of such transactions to a graph in the way that I'm going to show you next. So I'm not going to show you how exactly we translate such a transaction sets to the graph, but this is intuitively where the cryptographic security of these components would come in.

Okay, so let's go directly to step three, how to translate this into a directed graph. So the directed graph is going to look as follows. We're going to have two types of nodes, actually four types. So there's going to be a source, which is going to supply an initial amount of coins to the system. And then we have light gray nodes and they correspond to unspent outputs. Now each of these light gray nodes you see can be connected to one of these darker nodes, and the dark nodes are going to be transactions which spend those unspent outputs, and they're going to spend them into new unspent outputs. And then of course at the very end when the system ends or dies we're going to have a target node, and anything that wasn't spent at that time just goes into this target directly.

So this is our graph and now you see we have these labeled edges here and these labels actually correspond to the amount of this unspent output that is being transferred into the transaction corresponding to these dark gray nodes. So each of these arrows here can be labeled with such an amount, and that is how we build this graph.

So now here is a brief interlude. I told you that we want to apply some graph theoretic argument to this graph that we built. And just to give you a rough idea of how this will work, what we're going to use here is the theory of flow networks. So that sounds a little maybe abstract, but it's actually quite simple. So a flow network, what it means is basically you have a graph and this graph corresponds to a network of flows passing through a system. So each of these arrows will correspond to some flow going from one node to another node. And the property that is crucially exploited in a flow network is that for every node in the flow network, whatever goes in has to go out. So for example, you can see that the node just above the source, it gets as an input two flows, one 1, and what comes out is 2.

And if we have such a flow network, then we can consider something called an ST cut, which is defined as follows. So basically we can partition all of these nodes in the graph into two disjoint subsets, S and T, where S contains the source and T contains T, but otherwise there is no restriction on them. And now there is a very simple lemma that says that any cut in this network will have the same value. So what is a cut? Basically a cut is just a partition, as I said, of these nodes into two distinct sets, where one of them contains the source and the other the target. And now we just see how much flow goes over this cut. So as an example I could have a cut where the target is just one node in T and everything else is in S, then we can see that the value of the cut is three because what comes out of the left partition and goes into the target is exactly 3. But if I look at the cut where these blue nodes are in S and the black nodes are in T, then what is going out of S will be 4, but what goes back into S from T is 1, so the overall flow that goes out of S into T is still 3. And for this example it's the same thing. Okay, so any cut yields the same value.

Okay, so we use this now in our security argument after defining this graph. So first we have to argue that it is a flow network that also comes into our security analysis. But once we do that, then we can actually define a very simple ST cut as follows. Well, basically, we're just going to let the left half of this cut be the honest unspent transaction outputs corresponding to non-corrupt nodes that don't belong to the adversary. And the rest of these nodes are going to belong to the adversary. So those are the ones that it controls. And now we're asking how much flows from the honest parties, you know, unspent outputs over to the adversary. And we analyze this value. And then through a series of inequalities, which I'm not going to explain here in detail, because I think I'm running out of time a little bit, we are able to show that the amount of receipt coins is greater or equal to the amount of spent coins. So the intuition of course behind this is that, basically the flow should always be preserved, so it should not be possible to spend more coins than you receive, because this would amount to violating condition of a flow network in one of these nodes. And this is basically what this series of inequality shows here. So it's just a nice way of abstracting this problem and being able to mathematically analyze it.

Okay, so let me summarize what I talked about today.

So what did we see? What did we find out? So we had Monero and Ring-CT, and we had a new security model that we saw, and we proved the security of Monero and Ring-CT in a formal sense using a theory of flow networks.

So that concludes my talk, but I'm happy to take in any questions and thank you for listening.

_**Moderator:**_ All right. That was great. Thank you.

_**Julian:**_ Thank you.

_**Moderator:**_ If anything comes through in the chat, I will read it out loud, but so far I did not see anything pertains exactly to this. Maybe I'll give it a couple minutes just in case, you know, someone's writing something long.

Here's one. You said that security was proven, but anonymity not. What are the plans for approving the latter?

_**Julian:**_ Wait, I'm not sure I understand the question. So what is my problem? Could you repeat the question? I'm sorry.

_**Moderator:**_ Oh, yeah. I think this person may have been speaking to someone else in chat. Not sure. No, no, that was you. Sorry. You said that security was proven, but anonymity not, what are the plans for proving the latter?

_**Julian:**_ Oh, I see. Okay. Okay. So that's a good question. So the... Yeah, that's a good question. Now the issue is with that, first of all, it requires a very different set of arguments, because the anonymity guarantees, so we actually know that some of the anonymity guarantees are difficult to prove in Monero, because there are these graph-based attacks on anonymity, and it's very difficult to formally capture them. And we were thinking about this. But then we were actually speaking to some Monero developers and they told us that there was a plan to migrate to a new transaction system in the near future called I think Seraphis. And it's unclear to us whether it would make sense to analyze the anonymity properties of Monero as currently is, you know, when there is a new transaction system on the horizon, which might be easier to analyze or guarantee better anonymity. So at this point, we're not sure if we should… you know, wait for another year or go for whatever is currently online. And I guess we would appreciate feedback from the community actually on that.

_**Moderator:**_ Oh man, that happened again. Someone tried to send a message longer than 280 characters and Streamyard just ate it up. But it looks like they got it through. In a technical sense, do you think some cryptocurrency protocols or private communication protocols are too close to the bleeding edge, putting users at risk due to missing security proofs or insufficiently renewed security proofs?

_**Julian:**_ Yeah, that's a good question. So it's an interesting question because I think there's so much innovation coming out of this space. It's really amazing, right? There are so many smart people in this space, but a lot of them, of course, you know, and there's so many nice ideas, but of course, inevitably a lot of these ideas, they're maybe not 100% thought through. Sometimes they're like minor details, very difficult to see, and you really need a kind of formal training and have worked a couple of years in the space to be able to detect them. Right. So it's often, you know, like these cryptanalytic techniques that can be very, very subtle to apply. And there was obviously a lot of literature on this stuff. So it's not always easy to see where the vulnerabilities lie. But I think it's. Yeah. So I think, I think it's a double-edged sword, right? On the one hand, we have all of these amazing new applications coming out, and it's been great. I think the space has seen so much progress over the past one and a half decades. But I think with that, there is always a risk of there being something deployed that is not fully secure yet. And I'm actually not sure what to do about that. I think we're slowly moving towards a scenario where people are not able to do that are becoming more aware of this and trying to give formal security proves before deployment. But I think we're not completely there yet.

_**Moderator:**_ All right, it doesn't look like we have anything else. And Seth, our last speaker is ready to go. So thanks so much, Julian.

_**Julian:**_ Thank you. Okay, see ya, bye-bye.
