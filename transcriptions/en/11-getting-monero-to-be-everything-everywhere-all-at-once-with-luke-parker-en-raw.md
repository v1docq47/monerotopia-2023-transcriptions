# Luke Parker

_**Getting Monero to be Everything, Everywhere, All At Once**_

[https://youtu.be/prNvJWILkoI](https://youtu.be/prNvJWILkoI)

---

_**Luke:**_ Hello everyone, my name is Luke Parker. Today I’m presenting on "Getting Monero to Be Everything, Everywhere, All at Once". No, I have not seen that movie. I will not entertain discussion about it. But first, just to start with, a bit about me. Luke Parker, you may know me as Kayaba, or if I’m on Twitter or IRC, kayabaNerve. Turns out some other people watched anime when they were a teenager and also picked kayaba. I’m a developer and an informal cryptographer. I could kick all your asses at cryptography, but I also can’t audit Bulletproofs.

As a bit of history, I did the first Monero atomic swap. So I’ve been interested in trustless technology, decentralized exchanges, privacy for multiple years now. And currently I’m the lead developer of Serai. Serai is my own decentralized exchange, which I briefly talk about at the end of this presentation. But the short note is we’re trying to offer a high liquidity AMM for Monero while still being decentralized and secure. I’m also a Magic Monero Fund committee member. Magic is a 501c3 charity. So if you want to donate to Monero, and you’re a US citizen who also doesn’t like giving money to the IRS, reach out to us, we’ll take it. And we fund Monero development, we’ve funded a couple items in the past, we’ve also funded Ethereum-Monero atomic swaps, which will be talked about later. And then finally, I included this at the request of Justin Berman, I’m really good at Tetris. And if any of you want to fight me on that, I will.All right, so this talk isn’t about raising Monero awareness, it’s more about letting Monero be integrated into more and more things. So it’s talking about how Monero has a wallet software and it also has a lot of shortcomings. If we look past those shortcomings though, if we write our own wallet software, if we do our own development, and no, you don’t have to be a developer to appreciate this talk, but if we start considering these options, how we can move past them and put Monero in a lot more places. And if it’s in a lot more places, we’ll get used a lot more, all for more people using Monero.

It’s also partially a showpiece for my own work, Monero Serai. Serai is a decentralized exchange needed a lot of wallet functionality, while the official Monero wallet simply didn’t have. So because it didn’t have it, we largely rebuilt the wallet, and I talk about Monero Serai a good bit, I’ll be honest about that up front. But I also talk about a few other wallet implementations that have been developed over the years.

So just to start with - The Monero Wallet Protocol. So Monero transactions are validated under consensus. You can’t just make a transaction saying: "Give me one million Monero". Monero isn’t just its consensus protocol, which involves Ring Signatures and Bulletproofs. It’s also Stealth Addresses. And on chain, we don’t do any validation of stealth addresses. Sure, we store the results of stealth addresses on chain, but the Monero blockchain has no idea what Monero address is. So Monero address is simply - I get from my wallet and I send to your wallet, and your wallet interprets that stealth address however it will interpret it. So that’s one example of the Monero wallet protocol. And when your wallet receives a stealth address and it goes to send to it, it does a bunch of math with it, and it generates a one-time key. And then my wallet, and then, sorry, I’m getting my words a bit mixed up. If you’re sending funds to me, my wallet then scans the blockchain, it does the same stealth address math, and it looks to see if any of those one-time keys were to my address. And if they are, I say: "Great, I receive funds". And that’s kind of the Monero wallet protocol.

The interesting part is that while it’s expected that all wallets will use the wallet protocol, it’s the wallet protocol for a reason, we can do whatever we want. Instead of using stealth addresses, we can make up our own addresses and use those instead. You probably shouldn’t. Stealth addresses are great. But you can. And with Jamtis, the new addressing scheme that’s being proposed to go live with Seraphis, that was actually being proposed as an alternative address scheme for the current Monero, and it got rolled in with the Seraphis updates. So while I’ll have nothing as impressive of Jamtis in this talk, I do have some of my own addressing schemes to discuss.

So basically, the Monero wallet protocol gives complete freedom to wallets - they’re allowed to do whatever they want with it. So now the question is, why should we break from Monero? Why should we go our own route? And there’s a bunch of reasons. Even if you don’t break from the Monero wallet protocol, it might make sense to write your own implementation of the wallet, simply because Monero is largely written in C++. I know a lot of people who refuse to touch C++. The first Monero atomic swap was written in Rust, the Farcaster project was written in Rust, and then the recent Ethereum fork was written in Go. None of these projects are using C++. All of them do a lot of code with Monero. And it’s quite annoying to integrate Monero into these. So if we did have Rust libraries, if we had Go libraries, if we had JavaScript libraries, it would just massively simplify development and allow people to build more apps, more integrations, and so on.

Another reason is because Monero’s a large project. If we wanna make changes, they have to be reviewed. And that’s a good thing. We don’t want people making random changes to Monero risking breaking things or creating protocols we’ll get rid of in a month. But at the same time, that arguably stifles innovation. So when we have alternative wallet implementations, we get the freedom to try out experiments, go our own path, and they’ll live as long as they live, and if they work well enough, we can submit them back upstream to Monero proper.

Another benefit is because the existing Monero wallet is several years old, and it’s not designed exactly for the full RingCT lifetime. So if someone was to view it now, they could easily say, this is how a wallet should be built. Whereas wallet2, the current Monero wallet, is kind of a hodgepodge to what it needs to be instead of what it should be.And then my final reason is just creating a more robust ecosystem. wallet2 has had bugs in it in the past, most famously the burning bug. The burning bug is actually a fault with the Monero wallet protocol, which wallet2 as the official Monero wallet implicitly defines. And with more wallets, we can write code that is secure against wallet-specific bugs. And while, again, the burning bug was a protocol issue, so that’s arguably wouldn’t have been caught, there might be other bugs in any project. So having more code and more alternatives is always a good thing.

And now here is the honest slide, which I was bullied to include by my friend Rukniam - why this is all a bad idea and why this sucks.

There’s not clear available documentation on the Monero wallet protocol. The closest to it would be the quite helpful "Zero to Monero" written by koe, who’s in the back. And I don’t mean to dismiss it, I just also mean to say it is a very, very long PDF. And I feel like a lot of the wallet protocol could be much simpler and much more obviously represented.If you write your own wallet and it creates transactions even slightly difficulty, you have now broken privacy. Not only of your own transactions, but you’ve also harmed the privacy of everyone else to some degree. One example of this was MyMonero. MyMonero implemented this one function, the decoy selection algorithm slightly differently. And because they implemented it differently, you could kind of tell which transactions were made by MyMonero and which ones were made by the official wallet software. That was actually my next point - you have to implement an identical decoy selection algorithm. The decoy selection algorithm says what other outputs you use in your ring. It is very annoying and unfortunately my own work doesn’t implement it correctly, but I have a scapegoat. Justin Berman has promised for the last month he would do it, and he still hasn’t, so blame him for that.

And then finally they just require support and maintenance. Monero is a large project and it keeps growing. We’re looking at the Seraphis update and when Seraphis happens, all of my work is destroyed. But apparently there’s enough benefit, I still decided to do it.

So just to officially go over wallet2, wallet2 is the official Monero wallet code base. It’s in C++ as I said before, and it’s monolithic. It’s 14,000 lines, which is not a fun file to read over. I have not met a single Monero developer who has ever said they like wallet2. We have several wallet developers in our audience. Never heard any of them say they like it. They tolerate it. It works. But it also defines the Monero wallet protocol being the official Monero wallet, and it supports all the functions you generally need. You can scan the blockchain to see if you receive funds, you can send Monero to other people - the good old core Monero stuff. It also supports multisig. And this is where my talk really picks up.

So it does support multisig, and it supports threshold multisig. A threshold multisig says, you know, if there are five people, any three of them will be able to produce a signature and spend these Monero. It looks like the mathematic on my slide unfortunately got a bit messed up, but basically that long math statement there with the exclamation marks - that’s the complexity, that’s how long it takes to generate a threshold multisig wallet. Specifically an operation known as key generation, and it might be off by one or something, but at the scope it doesn’t matter. So if you create a 9-of-16 multisig, which is 51% of a 16-member multisig, 16 being the largest wallet2 officially supports, it takes 39,000 computations. And that’s tolerable. Computers are fast nowadays. That’s still accessible, but it’s not optimal. And this is what actually started me down my own path of working on Monero Serai.

So just because the next part of the talk is about multisig, I actually also gave a talk on it last year at MoneroKon, very passionate about it. If you are worried that you may die and you want your family to be able to recover your keys, I don’t wanna just give my mother or my sister my seed. What I wanna do is give them part of it so that they can come together, and if they mutually agree I’m dead, can’t just have my sister stealing my money, she did that enough when I was a kid, then they can access my wallet and recover my funds. But it could also be for corporations. If you’re an exchange, you don’t want to have a QuadrigaCX scenario: oh, CEO dies, guess we lost the money. And you also don’t want to have FTX level embezzlement, though of course FTX was organized and this one didn’t stop that.


So the building block of Serai, my own decentralized exchange project, instead of being atomic swap based, we went with a multisig approach for UX. And we’re actually looking at 67 out of 100 multisigs, which means that we’ll have roughly 100 validators, that’s our goal, and 67 of them would have to come together to be able to steal funds, and if they did, they would lose so much money, because they’re economically secured, that it’s not even profitable to do so. But with the previous math formula, from the previous slide, this monstrosity, if we wanted to do a 67 out of 100 multisig, it would take one octillion operations, aka one billion, billion, billion computations. Computers are fast, but not that fast. I also think the resulting wallet file would be petabytes. So, no.So because multisig just didn’t work for my use case, I started on Monero Serai. It’s written in Rust, so if anyone here has some very nice Rust code, yeah, you can just grab a native library in Rust for dealing with Monero. It also supports scanning, sending, receiving, so on and so on. And it also has a much more efficient multisig operation. If we did a 67 out of 100 multisig, it only requires 6,700 computations to create, whereas even the 9 out of 16 for wallet2 took 39,000. So even with much larger multisigs, we’re much more efficient. And Monero Serai continued to build several other improvements to the wallet protocol, which are further being used to enable more and more apps. In this case, I said how Multisig builds on Serai, and we’ll get to the next one.

Nostr. So Nostr was popularized after Twitter was sold to Elon Musk. A lot of Bitcoiners said: "Let’s just build our own Twitter". And I can respect that. Definitely a need for more social media protocols out there. And one of the things it supports is zaps. If you like a tweet, if you think: "Wow, this guy is putting out some great content", you can send them a micro payment on Lightning. And I support that. You know, micro payments, nothing wrong with that. And this created a lot of the discussion in the Monero community. How can we get Monero to be used for zaps? And this is a long discussion on if we should, why we want that, how would the Nostr community react? And I’m here to say, I don’t care. I know how to technically do it. So I’m going to yell about that. And if you guys do want Monero on Nostr, you should express that. There’s this one man in the audience in a very nice floral shirt, Justin Ehrenhofer, he has promised any Nostr feature asked of him at Monerotopia. For legal reasons, that was a joke.

So as part of zaps, they’re publicly visible. You can see how much a certain Nostr "event", that’s the formal definition of their tweets - an event, you can see how much a Nostr event has received. So you can be like: "Wow, people really like this event. They send out a whole Bitcoin". Or you can see: "Wow, no one ever wanted to send money to this event. Everyone hated it". So with Monero, we have a cryptographic proof for that. It’s called an OutProof. The OutProof just says: "Yes, I made a Monero transaction and in this Monero transaction I sent this address this amount".Two issues with those. One, they’re technically vulnerable to the burning bug. This was briefly brought up earlier in a previous talk. The burning bug is where you create two outputs that share a one-time key. And because they share a one-time key, they share a key image. So you’ll have two outputs with one key image, and a key image can only exist once on the blockchain. Accordingly, you can’t spend both outputs. You can only spend one, and as soon as you spend one, it burns the other. So that’s a short version of the burning bug.

The OutProof does say: yes, this transaction paid this person this amount, but it doesn’t guarantee that that one-time key was never reused, because it doesn’t have the scope - it doesn’t know the entire blockchain, it doesn’t know the entire network. It just says: yes, this specific transaction paid this person. So OutProofs, they require additional communication. They’re not the most technically efficient option, and technically they’re not a complete solution.

And this leads to a very complicated subject, which I’ll do my best to dumb down, called "honest sender outgoing view keys". An honest sender of… okay, sorry. Outgoing view keys say, if I send someone money, I can see that I sent money. In the case of Seraphis, they do offer outgoing view keys. Outgoing view keys in Seraphis only say that your outputs were spent. They don’t say anything about who they were sent to. In this discussion, outgoing view keys are a lot more vague. They can mean anything from being able to see that your funds were spent to if you have a list of addresses, being able to confirm if those addresses were actually paid in an outgoing view key transaction.


So Monero doesn’t have outgoing view keys right now. And if I make a payment, I can’t tell that I made the payment without the spend key. Ideally, with just the view key, you’re able to see: yes, I made the payment. And in some cases, ideally, with just the viewkey, you’re able to say: yes, this payment was to this address.

Despite not having officially outgoing view keys, it’s possible to define honest sender outgoing view keys, which means if the sender opts into it, if the person who creates a transaction says: yes, I want this transaction to be visible to whoever has the outgoing view key, then yes, whoever has the outgoing view key will be able to scan it. This isn’t cryptographically secure in that if the sender decides not to share that they’re making a transaction, no one knows they made a transaction, and that does break some protocols. But in this case, Nostr, where someone’s making a micropayment, a donation to what’s effectively a tweet, it works. If you wanted to tip someone on Nostr, you just define an outgoing view key of Nostr. And then anyone can look on the blockchain for transactions with an outgoing view key of Nostr. And once they see transactions with an outgoing view key of Nostr, they can say: oh, this paid a Nostr event. And then they can find which Nostr event it was and say: "Hey, this received funds". It would be fully secure as well. You’d be able to confirm that, yes, that Nostr event actually did receive funds and it actually received that exact amount.


This is actually more secure than the current Lightning proposal because the current Lightning proposal or the current Lightning improvement proposal is trust-based. Anyone just says: "Hey, I would like to send you money". And the person in response says: "Yes, I received this amount of money". As far as I can tell, you can lie and specify any amount of money. You can have a Nostr event which receives 30 million Bitcoin. So yeah, this is actually a bit more secure.


And then these have other users, ah, other uses. They can also be used to secure multisigs, which is one of the reasons I’m so excited for Seraphis. If you create a multisig transaction with three out of five signers, sure, those three signers know that they signed a transaction. They participated in signing. But the other two signers, they don’t know a transaction was signed. They can’t - they weren’t there for when it was signed, and that’s that. So an honest sender outgoing view key says, as long as the three signers in the multisig are honest, the other two will eventually be able to realize: "Hey, this transaction on the blockchain, we made this. Therefore, it must be us".

So that can also be used to secure multisigs, and it’s something Serai needs being multisig premise. So Monero Serai also implements honest sender outgoing viewkeys. We don’t support it as it would be needed for Nostr, but if anyone is interested in Nostr, wants to talk about that, I’d love to. And then once again, a note: yes, Seraphis does offer outgoing view keys as needed for a lot of protocols.

So that’s what’s up with Nostr, but there is another kind of case study here of things that could do a lot with Monero if only we mess with the protocol a bit. Just a little bit. Another case is Molly. This slide might be a bit small, I’m sorry if so. So Molly, it’s a Signal fork, but it offers a fully open source software variant, so there’s no proprietary code in it. Personally, I use it - it’s what I recommend. It actually had a CCS to integrate Monero. This was sometime after Signal did MobileCoin. And Molly was like: "Well, we also wanna have cryptocurrency, but we don’t exactly like MobileCoin. What if we just did Monero?"

So, the Molly developers ended up working on a Monero SDK for Android. They have an Android app, they wanna support Monero. They didn’t consider wallet2 feasible to integrate. One of the reasons why is wallet2 is written in C++ - C++ isn’t considered memory safe, which is quite important. 70% of all security issues in Microsoft were memory related. So using a memory safe language at Microsoft would have resolved 70% of security issues automatically. But unfortunately, wallet2 is in C++, which isn’t memory safe. Not to say the developers don’t take great care when writing it, but the Molly developers had concerns about that.

It also directly implemented networking. So if I believe the Molly developers wanted to ensure that even DNS requests were going over Tor or whatever proxy was specified, and there were concerns about if wallet2 was allowing that. And then finally wallet2 had log statements that were not being immediately encrypted. And Molly’s view of privacy and security says: yes, if we’re saying we did something, we’re encrypting it so only the user knows we did something.

So, Molly actually built an Android SDK. It is still built around wallet2. It just gets rid of a lot of the higher level code and really reaches into the guts. So, for their Android SDK, they fully integrated it with Android Studio. They sandboxed the C++, so if there are any memory issues, it’s contained to just the wallet2 code and not the rest of the Molly app or not the rest of the system.


They implemented client-side networking. So instead of routing their networking through wallet2, which also is client-side, but instead of routing it through the wallet2 library, they handle networking entirely on their own. And that gives them a lot more flexibility, a lot more control, and it also let them do client-side load balancing, which should offer faster performance for syncing, scanning transactions, sending, so on and so on. And then finally, they also added app-level privacy improvements such as encrypting all log statements. So even if I steal your phone, I can’t even get like logging data about what happened with your Monero.


And kind of the end lesson from this is we need wallet software which is flexible, customizable, controllable. You know, if someone wants to disable logs, they have to be able to disable logs. I do believe there’s a build statement in that for wallet2, I’m not trying to hate on wallet2 and say I can do this. I’m just trying to note how all of these pieces work together and how intelligent design is needed. wallet2 handling of networking, yeah, that wasn’t something cleanly outsourced apparently, according to the Molly developers, and that would be an area for improvement.This just goes a bit more into the networking side of things. Most wallets just connect over standard web connections, HTTP or, if you’re secure, HTTPS. Privacy conscious users use Tor. Other privacy conscious users use I2P, especially with the recent Tor DDoS attacks. So yeah, you really want the app to be able to say: "Use I2P, use Tor, oh no, just use a standard networking connection". And you really don’t wanna just trust whatever library you’re using to handle that unless it explicitly says it can handle that, explicitly provides APIs, and cleanly does so.


And then the other side of it is, when we get into the whole discussion, it’s about running in a browser. And there’s a lot of stupid reasons to run Monero as a web wallet, but there’s a lot of non-stupid reasons as well. But if you’re running in a browser, you can’t connect to Tor. You can’t connect to I2P. You can’t even make standard web requests. Literally none of this is available. You have to make browser-specific web requests through JavaScript. So now the question is how do we get C++ code to make web requests over JavaScript? And that’s its own very long conversation, and why you really shouldn’t just expect networking to be available in any library you ever write.

And I do know there’s discussions with the new Seraphis wallet along for a lot of these design discussions, but for me right now I’m focusing on our current wallet software and current options.


So if you do want to write your own custom net code, you have to really dig down to the guts of wallet2 and rewrite a lot of it. That’s what the Molly developers did. On my end, Monero Serai, I just let users specify whatever net connection they want. So that means they can immediately specify Tor net connection, immediately specify I2P, they can specify some browser specific networking protocol, they can use carrier pigeons. Just doing whatever it can to be the most flexible.Another use case for custom wallet software is actually hardware wallets. Currently, Monero is notably on Ledger and Trezor, and neither of them use wallet2. Both of them use their own implementations of the Monero wallet protocol. And I would say that’s because writing their own Monero libraries were considered more feasible than getting wallet2 to build for them. And I’m not saying they’re wrong, I’m saying they wrote thousands of lines of code just to not deal with wallet2 on their devices. And that’s perfectly reasonable. Hardware wallets are very resource constrained. They have very slow CPUs, very limited amounts of memory, whereas wallet2 is largely expected to be built or run on desktops, laptops, even phones, but phones still have many orders of magnitude more processing power than a hardware wallet. So it does make sense why wallet2 wasn’t feasible, but it is also unfortunate wallet2 wasn’t feasible.So Ledger did it in C++, Trezor did it in Python. And now there’s also discussions about Foundation’s Passport. It’s another hardware wallet. They’re also looking to support Monero. So there is discussions about what to do with that. They may end up going with the Trezor side of things, because they also have a lot of Python code, so they’re able to easily implement Trezor’s Python.


But personally, I put forth Monero Serai because of personal bias, I’m not gonna lie. I know the code, I’ve worked with it, I trust it. If I’m gonna work with something in Monero, I prefer to use my own work. But at the same time, it’s also just a competent wallet library, and it’s being extensively tested, and I also hope to have it audited within a few months. And the fact that Monero Serai is able to build for it in the first place kind of shows that yeah, you can develop a wallet library, or a transaction library in this case, that is able to work at high scales. I mean, I’m using it for an entire decentralized exchange. Yeah, here we’re now discussing using it for a hardware wallet, and then I believe Stack Wallet is looking at integrating it for their mobile wallet. So it’s definitely possible to build more intelligently designed wallets or just wallets tailored to specific use cases.

So I’m going to go ahead and show you this is kind of what I said just now. wallet2 wasn’t built with hardware wallets in mind. And this kind of continues. Hardware wallets take in a Monero transaction that doesn’t have signatures, known as an "unsigned transactions", and they produce their own signatures for it. The unsigned transaction format wallet2 defines, it does define one for cold wallets. It’s not the best. I’m sure there are someone who’s going to say: "Oh, I love the wallet2 unsigned transaction format. It works". It kind of just takes all of wallet2’s internal variables and saves them to a file and call it a day. So it works if you’re using wallet2. If you’re not using wallet2, you have to like exactly mirror all of wallet2’s variables and handling of this data in order to get at it. And some of the data isn’t designed with the most security in mind. I could get into a longer conversation there, but I’ll try to keep it brief. So basically in my opinion, the wallet2 unsigned transaction format, it’s not designed for performance and not only is it not designed for performance, I would question if it’s designed for security critical environments. I’m not here to say it’s insecure, I’m saying that it could be better designed to be more secure.

So accordingly, wallets can either implement it with its shortcomings or they can define their own protocol. And with Foundation Passport’s Monero-focused fork, they are currently discussing an unsigned transaction format which is minimal, is meant to be highly performant, very low data transmission cost, and does focus on security. It doesn’t let a malicious computer send data that shouldn’t be there. So, and this is actually something that I actually hope to be further upstreamed and contributed back. As I was originally talking about when I was saying: yeah, if we do alternative wallets, we have the ability to do alternative implementations and build better protocols. But the end goal of that should always be improving the Monero community as a whole. It’s not so we can fork off and make our own coins. It’s so we can make Monero more accessible and make Monero a more feature focused project.

Just to go over the burning bug a bit more - I’ve mentioned it more than enough, I’m sure - but yeah, it allows you to send Monero, which isn’t actually spendable. It actually gets tricky because the original burning bug said: you can send Monero and then you specifically can send Monero again, which isn’t spendable. So no matter what if someone triggered the burning bug, it had to be, because the one person who did both transactions was malicious. And if one person is does both transactions and is malicious - it’s just a malicious user and you can just kick them off and call it a day.

Unfortunately, the burning bug isn’t only possible by a malicious user. If you publish your view key, if you’re a charity, if you just want to be auditable, if you’re a layer two which publishes its own transaction data - any user can pull off the burning bug against any other user. And because any user can pull off the burning bug against any other user, you can’t tell which transaction was malicious. Because if Alice wants to send funds in, and then I walk in and I make my own transaction, and my transaction is first in the block, the protocol will see my transaction first, and they’ll see Alice, and they’ll be like: "Oh, Alice is malicious, they reused a one-time key", when in fact I reused a one-time key just to screw over Alice. And there are ways where this can be net neutral, where the attacker doesn’t lose any money, but they do cause other people to lose significant amounts of money. So the burning bug is definitely a concern, because it’s not just if you were the original sender, but even if you just have the view key.

There’s also implications for watch-only wallets which can’t detect when transactions are spent. And because they can’t detect when transactions are spent, they don’t know if the funds have actually been burnt yet. Because the funds are only actually burnt when one single output is spent.So "featured addresses", an address format I proposed, they’re not meant to be comparable to Jamtis. They’re just: hey, we don’t have Jamtis yet, I need this featured now, I’m gonna write a spec for it and let’s see what happens. Featured addresses - they’re immune to the burning bug. They also have greater functionality. I know one person who wanted to have a subaddress, but they also wanted to use a payment ID with their subaddress. When subaddresses were added to the Monero protocol, we kind of just said: why would you use a payment ID with the subaddress? The subaddress itself is the payment ID. But this one person has a use case for it, and because this one person has a use case for it, I added support for it, because featured addresses - we have features.

But the main thing is the fact that they can be immune to the burning bug. And if they’re immune to the burning bug that not only allows much more secure watch wallets, but that also greatly simplifies a lot of considerations when you’re developing higher level protocols. And in my case, the higher level protocol is decentralized exchange, but it could be a variety of other constructions. It could be atomic swaps, it could be payment channels, it could be whatever you wanna do with Monero, so on and so on. And then again, this also is being incorporated into Seraphis, I’m just impatient. So I wanna get these features now.

Choice of language - this is something I commented on earlier - wallet2 is in C++. One of the annoying things about C++ is there’s no standardized build system. So a lot of people use CMake and Make, which are very standard tools to build. CMake and Make do work on Windows. I know they technically do. They’re also very difficult to get working on Windows. So because C++ didn’t standardize a build system, and because we use standard build tools, but even the standard build tools can be difficult to work with. It legitimately can be very difficult simply to build wallet2 if you wanted to integrate it. I actually know multiple parties who are currently struggling to build it for Windows for distribution, which is unfortunate. And then even if you are familiar with CMake and Make and can get them running, the build scripts are hundreds of lines and not my favorite thing. They actually may be thousands.

So while you can call wallet2 from C++, because it itself is C++, if you wanna call it from any other language, you have to write bindings. Bindings are just little pieces of code in the middle that say: hey, you’re a JavaScript, hey, you’re C, hey, you’re Go, I wanna talk to this C++ instead. But if you could just have a library in your native language, if you could have a Go library for Go, if you could have a Rust library for Rust, you wouldn’t need an additional build process, you wouldn’t need additional bindings, you could just grab the library and use it. It’s the most seamless developer experience possible.

And then finally, I just noted again, C++ isn’t memory safe. 70% of Microsoft security issues were related to memory safety. But Rust and Python, which do have Monero transaction libraries implemented, those are memory safe languages. So not to say Monero right now: oh my gosh, it’s not memory unsafe. I’m not here to say don’t use wallet2. I am here saying that if you don’t want to worry about this class of bugs, alternatives are available.And then finally, just because I promised Doug, I said I would give a brief update on Serai at the end. We actually use most of the protocols mentioned here. These aren’t just: oh, cool things that could be done. But no, these are things that are actually being needed in development today by a bunch of protocols. Serai just being one of them.

So just to fully explain what Serai is - Serai is premised on financially bonded decentralized multisigs. So anyone can join the Serai multisig. We’re not saying: "Oh, they are KYC, and they are Cayman Islands shell company". No. If you put up the financial bond, you can be a multisig member, and then if you misbehave, we take the financial bond. So sure, if you get a super majority of people, yes, you could steal all the Monero, and we will just take your Serai and buy the Monero back.

We’re initially targeting Bitcoin, Ether, DAI, and Monero. The DAI is just for USD exposure option. And we actually use honest sender outgoing view keys just to determine when our multisig made transactions. Because we only require two thirds of parties to make transactions, and that other third is just kind of left in the dark. So honest sender outgoing view keys let the other thirds say: "Yes, this transaction was made. It was made as expected, and we can continue".

We also use featured addresses to not deal with the burning bug. If we had to deal with the burning bug, one user could say: "Hey, swap my 100 Monero to Bitcoin". And then another user could say: "Hey, swap my 100 Monero to Bitcoin". But only one of those Monero outputs would be spendable. And because only one of those Monero outputs would be spendable, only one would go through. So one user would get their swap, one user would completely lose their funds. So that’s why the burning bug is extra mischievous in our case, and why we really need featured addresses which are immune to the burning bug. And for Seraphis to come out.

Yeah, and all of this is really just necessary to properly build a decentralized exchange for Monero. It’s been a lot of work. I spent four, five months just on the Monero side of things.

It’s Serai’s project been under development for over a year now. It’s about to hit protonet, our prototype network - it’s a private testnet. Basic functionality - we’re able to handle Bitcoin and Monero. We’re able to connect to a peer-to-peer network and do signing data. We have a blockchain that we can put Bitcoin and Monero representations on, and then with protonet, we’ll be able to internally swap them and start building more integrations such as wallets and services.[Ad]

Do you love coffee and Monero as much as we do? Consider making gratuitas.org your daily cup. Pay with Monero for premium fresh beans, and if you like what you taste, send a digital cash tip directly to the Guatemalan farmers that made it possible. Proceeds help us grow this channel. Gratuitas and Monero.

We apologize for the interruption and loss of content, due to an unexpected power outage. Thank you for your understanding!

_**Luke:**_ …and you can’t tell, who’s paying for services, and who’s just making a regular transaction. So, Monero does include a fake payment ID, but only if you have two outputs. If you have more than two outputs, it doesn’t bother. I don’t know why that rule was made, but it was made, and I accidentally always included a payment ID. I’m all technically sure that’s valid if you’re sending to an address of the payment ID, and you have 10 outputs. Monero will include a payment ID but my behavior was slightly different, and that probably enables statistical analysis that would reduce privacy. So you really just have to get it exactly with Monero and that’s very difficult. For my decoy selection algorithm, I implemented code someone sent me, and I was told was correct, and I thought I implemented it correctly. I did not implement it correctly. We selected 16 outputs and 12 were coinbases. We are supposed to have a notable amount of coinbases thanks to P2Pool and so on. We’re not supposed to have 12 of them. So there is some bug, even though I thought I did it correctly, even when I kind of knew the protocol rules in that case.

So the main issue isn’t building a Monero wallet. It’s building a Monero wallet that’s exactly like Monero. But one of the things I’m hoping with is as we get cleaner wallets, whether it be Monero, Serai, or the new Seraphis Wallet - koe has put in a lot of work making sure that’s clean, proper, easily read, so on and so on. I am hoping more and more people understand the intricacies of it and are able to build their own software. Hopefully they don’t build their own software and instead they just fork off software, which is already built.

_**Audience:**_ […]

_**Luke:**_ Oh, not at all. I’m just noting that it should be much cleaner code, so hopefully when we do implement it, we have less of these random oddities that we have to find wherever in the Monero code base. I think the two output role is in CryptoNote-based TXutils and not anywhere in the wallet files, because I don’t know, whoever organized the CryptoNote folder. Well, technically I think they’re here, but that’s a conversation for another day. Any other questions? You can go again._**Audience:**_ The same question I asked the previous presentation. After doing so ambitious project. Any advice to the developers?

_**Luke:**_ You It takes more than a month. Hey, hey, hey, hey. I said three months. I said three months in our meeting, Justin. I am 400% or 300% over deadline, not 1,100 or 1,000, whatever, 1,100.

All jokes and idiocy aside. You either have to have someone really passionate about it, willing to work for free. Ideally, multiple people willing, really passionate about it and willing to work for free. I somehow scammed Justin Berman into agreeing to resolve my Monero issues, it was not for free. Couldn’t convince them to be a true believer. Anyways, so hopefully you have a few people who are willing to work for free, but if you don’t have that, it’s really just, you have to find people who actually know what they’re doing, not just they think they know what they’re doing, but they truly know what they’re doing, and not only do - they know what they’re doing. But you have to have the runway to support them, not only until the project launches, but for when your project goes over budget and has to do more work and has to do more stuff. I’m pretty sure Justin Ehrenhofer has a story here and there are Nostr clients to tell someday, but I’ll leave that for another day. So basically, either find suckers who are really passionate or have a lot of money. For some reason I said no pre-mine, and also no dev-fod, and also no dow, and there’s no ICO. I have spent a lot of money on this. Uh, yes.

_**Luke:**_ Personally, I believe it should be a completely arbitrary field. Right now, Monero puts wallet data in there. I don’t believe there should be any wallet data in there. I believe it should be completely optional. Variable length. I don’t feel a need to make it fixed size or like if present it has to be 256 bytes. And then I don’t care about it being encrypted. If people want to add an encryption test to it, I’m fine with that. I just don’t care.

Ideally, I would like it to stick around though. If it is removed, technically we have a workaround, it would just take a couple month of development. Anyone else?

_**Audience:**_ […]

_**Luke:**_ If I was to say one thing, my main frustration is the amount of people who commented on the GitHub and had no idea what they were talking about. I really appreciate how people do want to contribute to Monero. They want to make their voices heard because the Monero projects developers are there to serve the community. If we’re not there to serve the Monero community, why are we writing code? There would be no point. It was actually with the spirit that... No, I’m not going to tell that story. But I have to protect some privacy here.The main thing that was frustrating for me is that when community members did go to the GitHub issue and they commented because they wanted to be heard, they wanted to make sure the spirit of Monero stayed in line with them. And they either just repeated what was already said or they just didn’t understand the technicals. And they’re like: "Oh, I’m worried TX extra will lead to chain analysis being able to do this". But what they were describing didn’t require TX extra at all. It was completely possible without TX extra. So it really just showed how there are a lot of community members who are really passionate about Monero, which is great, but unfortunately they speak on issues they don’t know, and I worry about that muddying the waters. So while I don’t have a solution for that, because the only solution is for efficiency tests of some sort, which is bullshit, and how you create a gated community, what I do wanna say is, while I encourage community involvement, I encourage community members to ask questions on IRC before trying to make statements.

If that’s it, I’m fine just putting the mic down and going back to my seat, guys. All right. Thank you, everyone.
