# Доктор Джулиан Лосс

_**Комплексный анализ безопасности транзакций Monero**_

[https://youtu.be/BNIOep9flTU](https://youtu.be/BNIOep9flTU)

---

_**Модератор:**_ И следующим выступит Джулиан Лосс.

_**Джулиан:**_ Мой экран видно?

_**Модератор:**_ Да.

_**Джулиан:**_ Хорошо. Спасибо, что пригласили меня. Теперь я Или, извините, может, сначала должно быть какое-то вступление, или я могу просто начать?

_**Модератор:**_ Да. Как правило, выступающие начинают сразу.

Прошу прощения. Я волонтёр и не слишком хорошо знаю, кто есть кто. Моя задача - постараться сделать так, чтобы всё прошло гладко. Извините.

_**Джулиан:**_ Да, конечно, конечно. Я начинаю. В любом случае, спасибо.

Итак, я поделюсь результатами нашей недавней работы под названием "Комплексный анализ безопасности транзакций Monero". Работа проводилась в сотрудничестве с моим коллегой Казом Кремерсом и моим студентом Бенедиктом Вагнером.

Очевидно, я буду говорить о Monero, а конкретно о схеме транзакций Monero под названием RingCT. И чтобы создать общее представление о том, о чём я буду говорить, Monero, как все вы, вероятно, знаете, ведь это Monerotopia, является валютой, ориентированной на обеспечение приватности. Её рыночная капитализация составляет около 2,8 миллиарда долларов, а защита транзакций обеспечивается очень сложной системой, называемой RingCT, которая и является предметом нашей работы.

RingCT состоит из множества компонентов, которые я перечислил здесь. В первую очередь, это связываемые кольцевые подписи, обязательства, доказательства диапазона и скрытые адреса. Сегодня я на очень, очень абстрактном уровне расскажу о некоторых из этих компонентов и объясню, как они работают, а также как они объединяются в RingCT.

Итак, главный вопрос, на который мы пытаемся ответить: "Безопасна ли схема RingCT?". И если вы не имеете отношения к сфере доказуемой безопасности, то также можете спросить, почему возникает этот вопрос? И ответ таков: прежде всего, это очень серьёзная криптовалюта, и это очень, очень сложная система. И, насколько нам известно, не было представлено ни одного доказательства безопасности системы в целом, охватывающего все её аспекты. Существуют доказательства её отдельных компонентов, но комплексный анализ всей системы не проводился. И поэтому неясно, обладает ли она доказанными свойствами гарантии безопасности, о которых заявляется. Спойлер: да, обладает. Мы не нашли ни одной ошибки в протоколе транзакций, и нам удалось доказать, что он безопасен, что, надеюсь, очень даже хорошо. Ещё к этому хотелось бы добавить, что мы рассматриваем только безопасность транзакций, но не их приватность. Ну да ладно, с этим всё, перейдём непосредственно к предмету нашей работы.

Итак, основным результатом нашей работы являются разработанная нами абстрактная конструкция и модель безопасности RingCT. Нам удалось доказать безопасность RingCT в рамках этой конструкции и модели безопасности в соответствии с двумя целями, которые должны достигаться с точки зрения безопасности. Первая - злоумышленник не должен быть в состоянии украсть ни одной монеты в Monero. Вторая - у злоумышленника не должно быть возможности создать ни одной монеты. И если мы сможем доказать эти две вещи, значит Monero является безопасной криптовалютой.

Итак, наш анализ безопасности проводился в два этапа. Первое, что было сделано, но я не буду сегодня об этом рассказывать, мы смоделировали эту невероятно сложную систему транзакций, разбив её на множество различных компонентов. А затем мы провели очень подробный анализ каждого из компонентов. И как только мы получаем данные по безопасности всех этих компонентов, мы объединяем их и проводим системный анализ безопасности RingCT, который, конечно же, вытекает из безопасности всех этих различных криптографических компонентов. Под компонентами я понимаю множество различных вещей, которые были показаны на предыдущем слайде, например, особый тип связываемой кольцевой подписи, к которому я вернусь позже, компоненты выведения ключей, обязательства и так далее. К этому я ещё вернусь чуть позже. В этом докладе мы рассматриваем анализ на уровне системы, но не на уровне компонентов.

И сначала посмотрим, как работает RingCT. Для начала взглянем на то, как работают транзакции в популярных криптовалютах. Прежде всего, рассмотрим обычные транзакции, например, транзакции Bitcoin. При совершении транзакции Bitcoin, по сути, происходит простой перевод некоторой суммы криптовалюты от отправителя с адреса с открытым ключом, скажем, Элис, на адрес получателя с открытым ключом, допустим Боба.

С другой стороны, существуют зашифрованные транзакции, например, транзакции Zcash, в случае с которыми имеется гарантия, фактически доказуемая гарантия, что в пределах определённой группы, анонимной группы пользователей, обеспечивается полная анонимность, и никто не сможет получить никакой информации о каких-либо совершаемых транзакциях. В случае Zcash это будет защищённый пул, правильно? И, конечно же, это очень сильные гарантии приватности. Но, можно увидеть на примере Zcash, такие транзакции, как правило, проходят гораздо дольше и стоят дороже. Именно поэтому они не так часто используются, хотя и существуют.

А вот Monero я рассматриваю как нечто среднее между этими двумя крайностями. Благодаря подходу, называемому "смешиванием", Monero обеспечивает очень высокий уровень приватности. Подход подразумевает смешивание и перетасовке кучи транзакций, в результате которых невозможно понять, кто и сколько средств кому переводит. Это обеспечивает анонимность отправителей и получателей в рамках этой очень сложной системы. И это значительно усложняет отслеживание определённых платежей, проводимых из точки А в точку B.

Давайте подробнее рассмотрим анатомию обычных транзакций и то, какова она в случае с транзакциями Monero.

Вернёмся к предельно простому, элементарному примеру с Bitcoin. Транзакция будет выглядеть следующим образом. Если, скажем, Элис захочет перевести Бобу два Bitcoin, то она создаст транзакцию, в которой укажет себя в качестве отправителя, сумму и получателя Боба, а затем подпишет эту транзакцию своим секретным ключом, который может быть проверен любым человеком, обладающим её открытым ключом. В результате два Bitcoin будут переданы Бобу, после чего Боб сможет сделать то же самое, чтобы потратить средства, полученные в этой транзакции.

Идея заключается в том, что каждая обрабатываемая в данном случае транзакция в качестве входа фактически использует выход или неизрасходованный выход предыдущей транзакции. Поэтому всякий раз, когда вы проводите кому-то транзакцию, то всё, что остаётся, что не достаётся получателю, становится новым неизрасходованным выходом, который может быть потрачен в следующей транзакции. Мы называем это моделью неизрасходованных транзакций или UTXO.

Теперь немного рассмотрим, что происходит в случае с Monero. В данном случае используются транзакции с несколькими входами. Если раньше у нас был только один вход Элис, то теперь у Элис будет два неизрасходованных выхода, каждый из которых соответствует одному Monero или одному Bitcoin, и она хочет потратить их оба. То есть, транзакция с несколькими входами позволяет Элис тратить оба этих неизрасходованных выхода одновременно. В предыдущем примере я использовал один Bitcoin или один Monero в случае с обеими транзакциями, а теперь давайте посмотрим, что произойдёт, если у Элис будет, скажем, два неизрасходованных Monero в первой транзакции и три во второй. В этом случае останется одна монета, которая не будет передана Бобу, потому что Боб в этой транзакции получит только четыре Monero, а всё, что останется после этого, станет новым неизрасходованным выходом Элис.

И это мой пример. Элис использует одинаковое количество валюты в обоих своих входах, и, как вы увидите, важно добавить ссылки к каждому из этих входов, чтобы их можно было различать при создании транзакции.

А теперь перейдём к основным идеям RingCT. Первичной целью RingCT является сокрытие отправителей. Мы не хотим раскрывать, кто и кому отправляет. Для этого, на очень, очень концептуальном уровне, мы будем использовать примитив под названием "кольцевые подписи", о котором говорится в паре последующих слайдов. Вторая цель, которую мы хотим достичь, заключается в том, чтобы скрыть суммы переводимых между отправителями и получателями средств. Для этого используются криптографические обязательства. И третье, чего мы хотим достичь, - скрыть, кто получает средства, и для этого используются скрытые адреса.

И сначала рассмотрим именно третий компонент - скрытые адреса, поскольку я считаю, что именно их наличие отличает Monero от многих других криптовалют. Вот как это работает. У Боба, который является получателем этой скрытой транзакции, будет два долгосрочных секретных ключа, являющихся элементами Zp. kv при этом будет ключом просмотра, а ks - ключом траты. Они соответствуют двум точкам на эллиптической кривой. Это его открытые ключи просмотра и траты - долгосрочные ключи Боба.

Теперь если Элис захочет потратить оба этих неизрасходованных выхода Боба в данной транзакции, то она сделает следующее: она возьмёт случайной значение r из Zp, где p - порядок эллиптической кривой, которую мы используем, и затем сгенерирует это случайное значение, возведя базовую точку этой кривой в степень r. Затем она генерирует ключ выхода, взяв для этого ключ просмотра Боба и возведя его в степень r, о которой я только что сказал. Затем она хэширует ключ выхода, возводит базовую точку в степень этого хэша и умножает это на открытый ключ Боба, в соответствии с которым передаются её выходы. Теперь Боб, вычислив у себя ключ выхода, может проверить, принадлежит ли данный выход ему. А поскольку эти две операции перемещаются в экспоненте, то, по сути, это можно представить как мини-обмен ключами Диффи-Хеллмана, и тогда Боб сможет проверить, действительно ли транзакция предназначена для него. И если это так, то её можно потратить позже, вычислив ключ траты таким вот образом.

И здесь происходит кое-что ещё. Теперь Элис добавляет к транзакции обязательство по сумме. Для этого создаётся обязательство по сумме, которая переводится в данной транзакции, и это делается путём вычисления, скажем, обязательства Педерсена, с некоторой соответствующей обязательству случайностью, которую я обозначил здесь как cr. Итак, интуитивно понятно, что это обязательство мы будем использовать, как уже было сказано, для сокрытия сумм, которые здесь передаются, но об этом будет говориться уже на следующем слайде. А сначала посмотрим, как кольцевые подписи позволяют скрыть входы.

Итак, в транзакции Monero каждый пользователь предоставляет не только свои настоящие входы, но и ложные. Это делается с целью увеличения размера анонимной группы, ведь мы хотим, чтобы внешнему наблюдателю было очень сложно понять, сколько денег передаётся отправителем получателю в транзакции. Поэтому мы увеличиваем размер анонимной группы, добавляя в каждую транзакцию несколько ложных входов. На этом рисунке такие транзакции показаны светлым серым цветом. Чтобы как-то выделить их, мы будем ссылаться именно на них.

Теперь у нас остаётся две проблемы. И первая, которую нужно решить - проблема двойной траты, а вторая заключается в сохранении общего значения всех сумм, включённых в эту транзакцию и передаваемых получателям этой транзакции, на этом промежуточном уровне, где создаётся обязательство по входам, после чего они смогут быть потрачены получателями.

Как уже было сказано, для предотвращения двойной траты используются связываемые кольцевые подписи. Что такое связываемая кольцевая подпись? Для начала выясним, что такое кольцевая подпись в принципе. Если говорить очень абстрактно, кольцевая подпись - это обычная подпись, по сути, криптографическая подпись, но синтаксически подобная обычной подписи. У нас есть группа людей, назовём эту группу кольцом, желающих совместно сгенерировать подпись от имени группы. Участники этого кольца могут сгенерировать подпись, которая затем будет использоваться в качестве подписи от имени этой группы, но никто не сможет сказать, кто именно из участников кольца сгенерировал подпись. Это, собственно, и есть функция кольцевой подписи, обеспечивающая определённую степень анонимности.

Но у связываемой кольцевой подписи есть дополнительная функция, гарантирующая, что если кто-то пытается подписаться дважды, то есть один и тот же участник кольца попытается подписать две разные вещи, то специальный алгоритм эффективно свяжет эти попытки с одним и тем же пользователем и идентифицирует его. И это один из ключевых компонентов системы конфиденциальных транзакций Monero.

Итак, это первая попытка сохранить суммы в такой приватной транзакции. Отправитель хочет показать, что суммы, скрытые в этих двух точках, в данном случае обязательствах, показанных чёрным, тех, которые являются ложными обязательствами, равны сумме, указанной в обязательстве, соответствующем выходу. В чём здесь состоит идея? А идея состоит в том, что для этого мы будем использовать обязательство Педерсена, обладающее свойством гомоморфности. То есть, при наличии двух обязательств по входам, можно проверить, что всё то, чему принадлежит обязательство, соответствует обязательству по сумме входов. При этом не нужно точно знать, что находится в этих обязательствах. И вот уравнение проверки и обоснование, почему эта схема действительно работает.

И у нас остаётся ещё одна проблема - проблема приватности, ведь если мы наделяем обязательства этой гомоморфной функцией, то фактически позволяем использовать их для определения того, какие из входов являются ложными, соответствующими нулевым монетам, а какие настоящими, принадлежащими ненулевым монетам. Потому что если у меня есть ложный вход, я могу попытаться гомоморфно добавить его к любому другому из этих обязательств, после чего увижу, что сумма не изменится, и транзакция уже не будет приватной, и суммы в этих входах более не будут скрыты. И, безусловно, именно поэтому нам в первую очередь необходимы такие обязательства.

И как же нам решить эту проблему? Есть знаменитая цитата, приписываемая Дэвиду Уилеру, которая гласит: "Все проблемы в информатике могут быть решены добавлением ещё одного уровня косвенности". Не уверен, что это универсальная истина, но конкретно в случае с Monero это действительно так. Поэтому мы добавим именно такой "уровень косвенности", соответствующий тому, что называется ложными выходами. Вместо выходов, которые тратятся напрямую, у нас будет уровень ложных выходов. И теперь обязательства по ложным выходам должны обладать гомоморфным свойством, благодаря которому их сумма будет соответствовать обязательству по реальному выходу.

Но для того, чтобы их нельзя было связать с суммами в оригинальных транзакциях и использовать для определения того, какие из выходов являются ложными, будет использоваться кольцевая подпись, позволяющая совершать траты входов, соответствующих этим обязательствам. По сути, идея заключается в том, чтобы набор всех этих обязательств представлял собой группу пользователей, желающих подписаться. Это звучит немного странно, поскольку теперь каждое из этих обязательств также можно представить как обязательство с открытым ключом, соответствующим этой транзакции или этому входу. И в данном случае мы хотим показать, что одно из этих обязательств по входам с открытым ключом использовалось для подписания соответствующей суммы, которая была переведена по этому обязательству. Но при этом мы не хотим показывать, какое именно, потому что это указало бы на то, какие из входов являются ложными, а какие нет. Это очень, очень высокоуровневая идея, которая, если говорить абстрактно, предлагает рассматривать входы в качестве пользователей в кольцевой подписи.

И как только это будет реализовано, как только мы перейдём от входов к ложным выходам, мы разрушим эту связь, позволяющую отличить ложные входы от настоящих. И всё это благодаря добавлению этого анонимного уровня, использующего кольцевую подпись.

_[Реклама]_

_Вы любите кофе и Monero так же сильно, как и мы? А вам не хотелось бы начинать каждый свой день с чашки Gratuitas? Покупайте зёрна премиум-класса за Monero, и если вам придётся по душе их вкус, поделитесь цифровыми чаевыми напрямую с гватемальскими фермерами, которые позаботились о вас. Ваша поддержка способствует развитию нашего предприятия. Gratuitas и Monero._

_**Джулиан:**_ Остаётся только один вопрос: как будут верифицироваться транзакции в системе? По сути, необходимо проверить следующее: прежде всего, являются ли все входы предыдущими неизрасходованными выходами, а также все ли кольцевые подписи являются действительными. Также необходимо убедиться в отсутствии связи у подписей, поскольку если подпись связана, это означает, что кто-то пытался потратить один и тот же выход дважды в двух разных транзакциях, и это, конечно же, будет попыткой двойной траты, а это именно то, что мы хотим предотвратить. И наконец, необходимо проверить, сохраняется ли сумма транзакции, то есть, сохраняется ли сумма во входе в выходе. И для этого используется это гомоморфное равенство.

Итак, это был краткий обзор того, как работает RingCT. Это довольно сложная система, и я надеюсь, теперь вы понимаете, почему так трудно доказать безопасность данной схемы. И теперь перейдём к нашей модели безопасности.

Что касается модели безопасности, поскольку многие из вас, возможно, не знакомы с концепцией доказуемой безопасности, сначала выясним, что именно должна охватывать модель безопасности, как она работает и что из себя представляет. Итак, в рамках концепции доказуемой безопасности сама безопасность, и, кажется, я уже говорил об этом в начале презентации, безопасность рассматривается как формализованная игра между тем, кто ставит задачу, предлагает схему, в данном случае схему Ring CT, и злоумышленником, который пытается нарушить безопасность этой схемы. То есть злоумышленник, по сути, пытается выиграть в игре, нарушая то свойство безопасности, которое мы формализуем. И цель нашей работы состоит в том, чтобы формализовать такую игру безопасности, которая точно отражала бы всё то, что происходит в реальном мире, и перенести её на математическую модель. В этом и заключается наша цель.

И это означает, что в рамках нашей модели мы должны абстрактно отразить то, что злоумышленник может осмысленно сделать в реальном мире. Согласно нашей модели злоумышленник может создавать новых честных пользователей. То есть он может сделать так, чтобы кто-то занялся майнингом монет Monero и вёл себя как честный пользователь. Сделать это можно, например, с помощью фишинговой ссылки, отправленной письмом. Затем транзакции могут быть отправлены в систему, или же он может направить некоторые транзакции другим пользователям, участвовать в смешанных транзакциях, и так далее, и тому подобное. Он может заставить честных пользователей отправлять транзакции, то есть, обманом заставить их потратить что-то. Также он может взломать пользователя, то есть будет контролировать пользователя и все его средства. И в рамках нашей модели злоумышленник может сделать это в любой момент времени. И наконец, чтобы добавить немного денег в систему, мы также позволим злоумышленнику создавать "исходные" монеты, что, по сути, означает, что система будет наполнена какой-то валютой.

Итак, теперь формализуем условия победы злоумышленника в этой игре безопасности между нашим подразумеваемым создателем схемы и любым злоумышленником, пытающимся нарушить безопасность.

Итак, первое условие выигрыша для злоумышленника сводится к возможности кражи монет у честных пользователей, то есть траты монет честных пользователей, безусловно, при отсутствии знания их ключей. Второе условие - возможность создания монет злоумышленником из воздуха, что, конечно же, также подрывает безопасность честных пользователей, поскольку такие деньги ничего не стоят. В оставшейся части своего выступления я сосредоточусь именно на втором условии выигрыша, то есть том, как не дать злоумышленнику возможность создавать монеты из воздуха. Рассмотрим, как это можно формализовать.

Начнем с того, что есть некоторый инвариант или скорее переменная, называемая "получено". Это просто некоторое натуральное число. И всякий раз, когда злоумышленник получает несколько монет из какого-либо источника, от честного пользователя, полученная сумма будет увеличена на это число. Во-вторых, есть переменная под названием "потрачено", и всякий раз, когда злоумышленник потратит какие-либо монеты, отправив их честному пользователю, потраченная сумма будет увеличена на это число.

Таким образом, условие победы можно сформулировать как "потрачено больше, чем получено". Ведь это означает, что злоумышленник потратил средства, которые не получил, а это равносильно тому, как если бы он создал монеты из воздуха. И в этом случае противник выиграет.

Итак, это модель безопасности и цель злоумышленника. А теперь предельно кратко рассмотрим, как можно было бы доказать такую модель.

Итак, если мы возьмём эти транзакции - при этом не забываем, что у нас есть три слоя: входы, ложные выходы и обычные выходы - и теперь идея заключается в том, чтобы, пропуская некоторые детали, отобразить все эти транзакции, которые происходят за время жизни всей системы, в виде графа. Как только мы получим такой граф, мы сможем применить аргументы теории графов, которые покажут, что злоумышленник не способен потратить больше монет, чем он получает. И всё это будет сводиться к такому аргументу.

Ключевая сложность доказательства состоит в том, чтобы показать, что любое поведение противника, которое он может продемонстрировать в рамках этой абстрактной системы, может быть перенесено в уникальный граф, который мы сможем впоследствии проанализировать. Именно в этом и проявляется криптографическая безопасность всех компонентов системы, поскольку если бы эти компоненты не были безопасными, мы не смогли бы спроецировать каждый набор таких транзакций в графе так, как это будет показано дальше. Я не стану показывать, как именно мы проецируем такие наборы транзакций в графе, но интуитивно понятно, что именно в этом и заключается криптографическая безопасность данных компонентов.

Итак, перейдём непосредственно к третьему шагу, как перевести всё это в направленный граф. Направленный граф будет выглядеть следующим образом. У нас будет два типа узлов, хотя на самом деле их четыре. Это будет источник, который будет поставлять в систему начальное количество монет, а также светло-серые узлы, соответствующие непотраченным выходам. Каждый из этих светло-серых узлов может быть соединен с одним из этих тёмных узлов, а тёмные узлы будут транзакциями, в которых тратятся непотраченные выходы, то есть, они будут проводиться для новых непотраченных выходов. И, конечно, в самом конце, когда жизненный цикл системы подойдёт к концу, у нас будет целевой узел, и всё, что не было потрачено к тому моменту, просто перейдёт на этот целевой узел.

Итак, это наш граф, и теперь мы можем увидеть, что у нас есть помеченные ребра, и метки фактически соответствуют сумме в непотраченном выходе, которая передаётся в транзакции, соответствующей этим тёмно-серым узлам. Таким образом, каждая из этих стрелок может быть помечена такой суммой, и именно так строится этот граф.

А теперь небольшая интерлюдия. Как я уже сказал, мы применяем некоторые аргументы к графу, который построили. И чтобы вы примерно представляли, как это работает, мы будем использовать теорию поточных сетей. Звучит немного абстрактно, но на самом деле всё очень просто. Итак, поточная сеть предполагает наличие графа, и соответствующего сети потоков, проходящих через систему. Таким образом, каждая из этих стрелок соответствует какому-то потоку, идущему от одного узла к другому. И одно из самых важных свойств поточной сети заключается в том, что для каждого узла в такой сети всё, что входит в неё, затем должно из неё выйти. Так, например, как здесь показано, узел, расположенный прямо над источником, принимает два потока, один обозначен как 1, а на выходе получается 2.

При наличии такой потоковой сети мы можем рассмотреть нечто, называемое срезом ST, который определяется следующим образом. По сути, мы можем разбить все эти узлы графа на два непересекающихся подмножества, S и T, где S содержит источник, а T содержит T, но в остальном в их отношении нет никаких ограничений. И согласно очень простой лемме любой срез в этой сети будет иметь одно и то же значение. Так что же такое срез? По сути, как я уже сказал, это просто разбиение этих узлов на два разных набора, один из которых содержит источник, а другой - цель. А теперь посмотрим, какой поток проходит через этот срез. В качестве примера можно взять срез, где целью является только один узел в части T, а всё остальное находится в S. И как мы видим, значение среза равно трём, поскольку то, что выходит из левой части и попадает в цель, равно 3. Но если посмотреть на срез, где синие узлы находятся в S, а чёрные - в T, тогда то, что выходит из S, будет равно 4, а то, что возвращается в S из T, равно 1, так что общий поток, который идет из S в T, по-прежнему равен 3. И в случае с этим примером это одно и то же. Таким образом, любое сокращение даёт одно и то же значение.

Итак, определив этот граф, мы используем его в нашем обосновании безопасности. Сначала мы должны доказать, что это потоковая сеть, что также является частью нашего анализа безопасности. Как только мы это сделаем, мы сможем определить очень простой срез ST следующим образом. Левая половина этого среза будет содержать честные непотраченные выходы транзакций, соответствующие не взломанным узлам, которые не контролируются злоумышленником. А остальные узлы будут контролироваться им. То есть, это уже будут те узлы, которые он контролирует. И теперь мы смотрим, сколько средств перетекает от честных узлов, то есть, сколько непотраченных выходов уходит к злоумышленнику. Мы анализируем это значение, а затем с помощью ряда неравенств, на которых я не стану останавливаться, потому что у меня уже заканчивается время, в общем, мы можем показать, что количество полученных монет больше или равно количеству потраченных монет. Смысл, безусловно, заключается в том, что поток всегда должен сохраняться, и поэтому не должно быть никакой возможности потратить больше монет, чем получить, потому что это было бы равносильно нарушению правил потоковой сети одним из этих узлов. И именно это демонстрирует эта серия неравенств. Так что, это хороший способ абстрактного представления этой проблемы и хорошая возможность проанализировать её математически.

И теперь подведём итог всему тому, что было сегодня сказано.

Итак, что мы увидели, что выяснили? Мы рассмотрели Monero и Ring-CT, рассмотрели новую модель безопасности и формально доказали безопасность Monero и Ring-CT с помощью теории потоковых сетей.

На этом я закончу своё выступление, буду рад ответить на любые вопросы и благодарю вас за внимание.

_**Модератор:**_ Отлично. Это было здорово. Спасибо.

_**Джулиан:**_ Спасибо.

_**Модератор:**_ Если что-то появится в чате, я зачитаю, но пока что не появилось ничего по нашей теме. Может, я дам пару минут, вдруг кто-то пишет очень длинный вопрос.

Вот, есть вопрос. Вы сказали, что безопасность доказана, а анонимность - нет. Каковы ваши планы по доказательству последней?

_**Джулиан:**_ Минутку, не уверен, что понял вопрос. В чём состоит проблема? Не могли бы вы повторить вопрос? Извините.

_**Модератор:**_ Да, конечно. Думаю, этот человек, возможно, разговаривал с кем-то другим в чате. Не уверен. Нет, нет, это был ты. Прошу прощения. Вы сказали, что безопасность доказана, а анонимность - нет. Каковы ваши планы по доказательству последней?

_**Джулиан:**_ Ясно. Я понял. Хороший вопрос. Действительно хороший вопрос. Проблема в том, что, во-первых, это требует совсем другого набора аргументов, и мы знаем, что некоторые гарантии анонимности Monero доказать трудно, потому что существуют схемы атаки с целью деанонимизации на основе графов, и их очень трудно отразить формально. Мы думали над этим, но потом пообщались с разработчиками Monero, и они рассказали нам, что в ближайшем будущем планируется переход на новую систему транзакций под названием, кажется, Seraphis. И нам неясно, имеет ли смысл анализировать свойства анонимности Monero в их нынешнем виде, когда на горизонте уже появилась новая система транзакций, которую, возможно, будет проще анализировать или которая будет гарантировать лучшую анонимность. Так что на данный момент мы не уверены, стоит ли нам подождать ещё год или заняться тем, что уже сейчас есть в сети. Пожалуй, мы были бы признательны, если бы сообщество выразило своё мнение по этому поводу.

_**Модератор:**_ Боже, это снова произошло. Кто-то попытался отправить сообщение длиннее 280 символов, и Streamyard просто сожрал его. Но, похоже, сообщение всё же прошло. Как вы считаете, в техническом смысле не являются ли некоторые криптовалютные протоколы или протоколы обмена приватными сообщениями слишком передовыми, и не подвергают ли они тем самым пользователей риску из-за отсутствия доказательств безопасности или недостаточного обновления доказательств безопасности?

_**Джулиан:**_ Да, это тоже хороший и интересный вопрос. Я думаю, что в этой области появляется довольно много инноваций. И это просто здорово, верно? В этой области работает много умных людей, и у многих из них, конечно же, есть масса хороших идей. Но, безусловно, неизбежно многие из этих идей не продуманы на 100%. Иногда это какие-то мелкие детали, которые очень трудно заметить, и в этом случае нужно иметь специальное образование и проработать пару лет в этой области, чтобы суметь их обнаружить. Верно. Так что зачастую методы криптоанализа могут быть очень, очень тонкими в применении. И, очевидно, есть масса литературы по этому вопросу. Так что не всегда легко понять, где находятся уязвимости. Но я думаю, что это так. Да. Я думаю, это обоюдоострое оружие, верно? Появляются все эти замечательные новые приложения, и это здорово. Думаю, за последние полтора десятилетия в этой области случился большой прогресс. Но я считаю, что при этом всегда есть риск того, что будет развёрнуто нечто не до конца безопасное. И я не знаю, что с этим делать. Я думаю, мы всё же постепенно движемся к сценарию, когда люди, не способные сделать это, всё же становятся более опытными и пытаются предоставить формальные доказательства безопасности перед развёртыванием. Но, на мой взгляд, мы ещё не прошли этот путь до конца.

_**Модератор:**_ Хорошо, похоже, вопросов больше нет. И наш последний участник на сегодня, Сет, готов к выступлению. Большое спасибо, Джулиан.

_**Джулиан:**_ Спасибо. До встречи, пока!
