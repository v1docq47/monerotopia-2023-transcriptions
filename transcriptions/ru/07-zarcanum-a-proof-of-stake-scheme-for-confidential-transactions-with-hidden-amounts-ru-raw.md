# Sowle & koe

_**Zarcanum: Использование схемы доказательства ставки при проведении конфиденциальных транзакций с сокрытием суммы**_

[https://youtu.be/6NQ-TiE5syY](https://youtu.be/6NQ-TiE5syY)

---

_**Даг:**_ Сегодняшний день посвящён технологиям обеспечения приватности в целом, а не только Monero. Мы только что прослушали выступление о технологиях обеспечения приватности Bitcoin, а теперь настала очередь Zano. На днях мы уже немного узнали об этом, но теперь нам расскажут о Zarkanum, о схеме доказательства ставки, над которой они работают, или которую они уже разработали. Правильно? Она уже готова?

_**Sowle:**_ Да, она уже разработана. На самом деле она уже работает в тестовой сети Zano с ноября.

_**Даг:**_ Итак, перед нами выступит Sowle. Так?

_**Sowle:**_ Да, всё верно. Меня зовут Вэл, но, возможно, я более известен под ником Sawle. Я являюсь исследователем и разработчиком в проекте Zano.

_**Даг:**_ И эта схема была реализована в сотрудничестве с koe, который до этого, как мне кажется, был более известен по работе над вещами, связанными с Monero, верно?

_**koe:**_ Да, они попросили меня взглянуть на их документацию, и в итоге я начал помогать им.

_**Даг:**_ Просто восхитительно, что они оба выступают здесь перед нами, и очень приятно наблюдать подобное сотрудничество в сфере технологий обеспечения приватности. Начинайте.

_**Sowle:**_ Спасибо. Всем видно курсор на экране? Хорошо, супер.

Итак, сегодня мы расскажем о схеме доказательства ставки. С самого начала в Zano нами использовалась гибридная схема доказательства работы и доказательства ставки, которая изначально была разработана и реализована в Cryptozorg. И в какой-то момент мы решили, что в основу нашей монеты ляжет протокол CryptoNote, поскольку Zano - это эволюция Blueberry, а Blueberry - один из вариантов реализации CryptoNote. И в какой-то момент мы решили, что нам нужно двигаться дальше и внедрять механизм сокрытия сумм. А в Zano на тот момент уже использовался консенсус доказательства работы и доказательства ставки. Поэтому перед нами встала новая задача: как реализовать механизм сокрытия сумм поверх существующего консенсуса доказательства ставки.

И для начала я немного расскажу о том, как работает стохастическая схема доказательства ставки. Существует несколько моделей доказательства ставки. Одна из них - стохастическая схема доказательства ставки, о которой мы сегодня и будем говорить. Пожалуй, наиболее известной моделью доказательства ставки является pBFT, которая, насколько мне известно, получила достаточно широкое распространение. Поэтому сегодня мы остановимся на той модели, которая была  реализована проектом Zano. Мы считаем её эгалитарной, поскольку она не требует наличия списка фиксированных валидаторов или чего-то подобного. И я вкратце расскажу о том, как работает эта стохастическая модель доказательства ставки. По сути, эта модель впервые была реализована PeerCoin, если не ошибаюсь, в 2012 году, а уже позже Zano и другими проектами. Итак, вкратце о том, как она работает.

Здесь показан блокчейн, который растёт по направлению вниз, и кошелёк, полный UTXO - неизрасходованных выходов транзакций. Представим, что это кошелёк Элис, и представим, что она хочет вычислить новый блок, используя схему доказательства ставки. Здесь, слева, можно увидеть, что в блокчейне одновременно присутствуют блоки, созданные по схеме доказательства ставки и по схеме доказательства работы. В блокчейне Zano имеется примерно по 50 процентов каждого вида. И первое, что нужно сделать Элис, это заполнить специальную структуру, структуру данных, которая очень проста и состоит всего из четырёх полей. Первые два поля, по сути, отражают текущее состояние блокчейна. Они содержат хеш последнего известного блока, созданного по схеме доказательства ставки, и хеш последнего известного блока, созданного по схеме доказательства работы. Затем следует набор возможных временных меток, необходимых для того, чтобы ограничить количество попыток Элис для каждой итерации схемы доказательства ставки. А для последнего поля берётся выход из кошелька Элис, для которого вычисляется образ ключа. Безусловно, Элис может это сделать, поскольку владеет этим выходом. Полученный образ ключа помещается в последнее поле. По завершении заполнения структуры данных Элис вычисляет криптографический хеш.

В результате вычисления этого криптографического хеша Элис получает некоторое значение. И мы можем рассматривать его как случайное, поскольку не можем предсказать значение этого хеша. Обо значим его как значение H. И после этого, аналогично тому, как это происходит в случае с майнингом по схеме доказательства работы, после получения хеша он сравнивается с неким граничным значением, которое было задано для данной итерации. И если значения хеша, который является совершенно случайным, меньше граничного, условие считается соблюдённым, и Элис может создать блок по схеме доказательства ставки.

Чтобы обеспечить зависимость от фактического количества монет, имеющихся у Элис, это граничное значение включает в себя фактическое количество выходов, которое было выбрано Элис для данной итерации доказательства ставки. Кроме того, здесь используется текущее значение сложности схемы доказательства ставки. Это означает, что чем больше сумма в определённом выходе, имеющемся у Элис, тем больше у неё шансов выполнить условие. И сложность обеспечивает соответствие этой системы требованиям сети. Таким образом, по мере майнинга всё большего количества монет сложность возрастает - всё точно так же, как в случае с классическим консенсусом доказательства работы. И эта система работает очень хорошо, потому что она довольно проста. И я бы хотел...

_**koe:**_ Здесь я хочу подчеркнуть, что эта конструкция этой схемы аналогична конструкции схемы доказательства работы гораздо в большей степени, чем можно было бы ожидать. После того, как блок будет создан, время дискретизируется на временные компоненты. По мере того, как истекает время каждого такого компонента, выполняется тест. Так что, как и в случае с доказательством работы, где майнер занимается непрерывным вычислением нонсов, в рамках модели доказательства ставки по мере истечения времени каждого временного блока, вы пересчитываете хеш всех выходов UTXO, которыми владеете. Это то, что я привнёс в протокол доказательства ставки.

_**Sowle:**_ Да, спасибо. И это граничное значение, которое используется для возможных временных меток, определяется правилами сет, и, по сути, эти возможные временные метки дискретны. То есть, они идут с делением в 50 секунд. Это означает, например, что если Элис проверит все свои выходы в кошельке согласно этому неравенству, и ни один не будет соответствовать условию, то Элис придётся ждать 50 секунд, чтобы получить другой возможный набор этих временных меток. Таким образом, затраты, связанные с вычислительными ресурсами,  сводятся к минимуму, поскольку все выходы проверяются только один раз. После этого придётся подождать возможных изменений в состоянии сети. Например, если кто-то добавит блок, созданный по схеме доказательства работы или по схеме доказательства ставки, это изменит данную часть, и в результате вы получите другой набор хешей и другой набор шансов на то, что условие будет соблюдено. Это как лотерея, как будто у вас здесь есть лотерейный билет, который стоит дороже и пропорционально стоимости даёт вам больше шансов на выигрыш. И выходы, имеющиеся в кошельке, можно рассматривать в качестве таких билетов. Таким образом, вы пропорционально увеличиваете количество шансов. И если у меня есть только одна монета, а у кого-то имеется 100 монет, то у этого человека будет в 100 раз больше шансов на то, что условие будет соблюдено.

Теперь, когда мы понимаем, как работает стохастическое доказательство ставки, можно рассмотреть и проблему этой конструкции, которая возникает, когда речь заходит о сокрытии сумм. При сокрытии сумм при проведении конфиденциальных транзакций Monero суммы скрываются и фиксируются с помощью обязательств Педерсена. Таким образом, в блокчейне суммы не являются публичными. И проблема в случае с данной конструкцией заключается в следующем - мы просто не можем использовать этот подход. В данном случае буквой A обозначена сумма. Мы больше не можем использовать это решение, например, в случае с наблюдателями, присутствующими в сети, публичными узлами, которые отвечают за поддержание актуальной версии блокчейна кошельками и за каждый блок, созданный по схеме доказательства ставки. Это просто невозможно реализовать. И в данном случае решение состоит в использовании другого подхода, другого неравенства, которое будет проверяться Элис всякий раз, когда она захочет создать блок по схеме доказательства ставки. Итак, если вкратце, здесь у нас имеется сумма, которой обладает Элис имеет в каком-то из своих выходов, и эта сумма A зафиксирована в обязательствах Педерсена с применением некоторой случайной маски f. Это классический способ сокрытия суммы в обязательствах Педерсена.

Можно заметить, что в этом неравенстве мы по-прежнему используем A в её непосредственной форме. Так в чём же смысл? Ведь мы хотели бы как-то избавиться от этого. Тогда позвольте показать, как работает маска. Основная идея заключается в том, чтобы это неравенство, которое очень затруднительно применить к обязательствам, преобразовать в равенство, а затем использовать гомоморфное свойство обязательств Педерсена для его обработки. Так как здесь у нас есть неравенство - что-то меньше чего-то, некоторая постоянная величина, умноженная на A, здесь мы можем представить всё это неравенством, то есть, у нас будет D, умноженное на A минус некоторая известная величина ba. И как только мы применим это ограничение к этим переменным, мы получим тот же результат с этим неравенством. И основная идея состоит в том, чтобы использовать доказательство диапазона, которое у нас уже есть и которое используется для того, чтобы убедиться, что при проведении конфиденциальных транзакций баланс корректен. То есть, идея состоит в том, чтобы использовать доказательство диапазона для значения ba, чтобы преобразовать это неравенство в равенство.

_**koe:**_ Мне бы хотелось немного прояснить то равенство, о котором он говорит. Итак, в неравенстве мы имеем некоторое число, которое меньше некоторого большого числа. И это большое число разложено на A. Таким образом, это некоторое число, умноженное на A. Поэтому мы знаем, что меньшее число, хеш кратен A минус некоторое число, которое меньше A. Так как это некоторое число меньше A, мы можем раскрыть множитель, то есть множитель D, мы можем публично раскрыть его, а затем предоставить верификатору доказательство диапазона с помощью  вычитания.

_**Sowle:**_ Да, именно так. И как только мы приходим к этому равенству, мы можем без труда перестроить его, как здесь и показано, переместив все переменные в левую часть. И как только мы дойдем до этого места, следующим шагом станет составление другого равенства, очень похожего на предыдущее, с использованием этого допуска. То есть мы вводим ещё одну переменную, эти переменные D, f, H и A нам уже известны, поэтому мы можем просто произвести вычисление. Как только это будет сделано, мы получим вот это уравнение, которое очень похоже на предыдущее. То есть оно обладает тем свойством, которое мы, собственно, сейчас и будем использовать. Хочу отметить, что в этом равенстве H обозначает хеш, который, как мы уже говорили, вычисляется с помощью этой структуры данных. Так что этот хеш может вычислить любой, кто занимается просмотром блокчейна и анализирует блоки, созданные по схеме доказательства ставки. f - это специальная маска, которая используется в обязательстве Педерсена, и это скрытое и приватное число. Таким образом, только отправитель и получатель будут знать сумму. A - это сумма, и так как суммы скрыты, то и это значение будет скрыто, и только отправитель и получатель будут знать его. Переменная D будет публичной. И для последнего значения, для ba, мы приводим доказательство диапазона, чтобы при нулевом разглашении доказать, что оно меньше 2 в степени 64. И как только мы приходим к этому, мы получаем систему аналогично выглядящих равенств.

В данном случае нам известны все эти значения, и мы можем умножить каждый элемент в левой части на генератор H и генератор G. Это генераторы на эллиптической кривой, которая используется... простите... Итак, мы используем стандартную... Да, правда? Мы используем стандартную эллиптическую кривую ed25519, и на этой эллиптической кривой мы используем стандартный генератор G. Также у нас есть несколько генераторов H, которые никак не связаны между собой. Поэтому, когда мы умножаем каждый член в левой части на соответствующий генератор, и в итоге... прошу прощения. Почему-то включился режим редактирования. Я точно не собираюсь редактировать свою презентацию. Да, спасибо. После этого, поскольку эти генераторы не связаны друг с другом криптографически, мы можем объединить эту систему, состоящую из двух уравнений в одно уравнение. Но это уравнение будет вычисляться с точки зрения участника группы. Итак, это основное уравнение показано здесь, где мы имеем значение A′ равное f, умноженное на H плюс a, умноженное на G. A - это обязательство, которое у нас имелось ранее. То есть это обязательство по сокрытой сумме. А B - это обязательство по значению ba, которое будет использовано для доказательства диапазона. Таким образом, с помощью значения B, мы будем доказывать, что значение ba меньше 2 в степени 64.

_**koe:**_ По сути, мы объединили эти два значения, и они сводятся к A′, эти два сводятся к A, а эти два - к B. Таким образом, A - это первоначальное обязательство по UTXO, которому соответствует ставка. И мы делаем это, поскольку A и F являются частью этого равенства, но оба этих значения скрыты внутри A. Поэтому нам и нужна такая зеркальная стратегия с A′, позволяющая утверждать что-либо или производить вычитание в рамках гомоморфной системы.

_**Sowle:**_ Ну и, это почти что всё. Это наглядно демонстрирует, как можно создать простейшее доказательство. Имея это равенство, мы можем раскрыть D, мы можем раскрыть зеркальные обязательства A′ и B. Значение A нам уже известно, потому что A - это основное обязательство по нашему выходу. И тогда нам нужно доказать, что A′ является зеркальным обязательством A, что легко сделать с помощью доказательства, навроде доказательств, построенных по схеме Шнорра. Также необходимо доказать, что ba меньше 2 в степени 64. Для этого нами используются необходимые доказательства диапазона. И как только при нулевом разглашении мы приводим эти доказательства, мы приходим к выводу, что это неравенство действительно выполняется с очень небольшими исключениями. И это действительно демонстрирует, что если... извините. Итак, если мы предоставим такие доказательства с нулевым разглашением для нашего блока, созданного по схеме доказательства ставки, каждый верификатор сможет проверить эти доказательства в блокчейне и прийти к выводу, что неравенство выполняется. Это означает, что Элис действительно создала блок по схеме доказательства ставки, и ей действительно полагается соответствующее вознаграждение.

_**koe:**_ В случае с нашей схемой есть некоторые проблемы. В рамках модели, которая обсуждалась до этого момента, предполагается, что UTXO, по которому делается ставка, непосредственно указывается при попытке получить вознаграждение согласно ставке. То есть заявитель говорит: «Это мой UTXO, на который я сделал ставку, и вот соответствующие доказательства». Но что, если мы собираемся создать кольцевую подпись, состоящую из шести UTXO. Как определить, ставка по которому из них сработала, с помощью которого из них был создан блок? Вот тут и возникает проблема: когда мы создаём кольцевую подпись, чтобы скрыть участника, выход в кольцевой подписи, можно задействовать «псевдообязательство» по выходу. То есть это будет замаскированная версия обязательства по сумме оригинальных UTXO. Причём маска, используемая для этого нового псевдообязательства, будет случайной. Поэтому мы не сможем использовать эту маску напрямую, так как ею сможет манипулировать тот, кто делает ставку, чтобы выполнить условие - как здесь уже говорилось, в этом случае будет очень просто обмануть систему.

Поэтому нами создаётся другое псевдообязательство по выходу, которое строится иначе, чем это обычно делается в RingCT. Вместо того чтобы расширять существующую маску, которая была применена к генератору G, мы добавляем новый генератор X, чтобы замаскировать обязательство по сумме в UTXO, по которому сделана ставка. Таким образом, применение маски к новому генератору отделяет его от f, от маски f, которая использует вычисление соответствия ставки условию. И поэтому для того, чтобы включить этот генератор X, нам необходимо создать доказательства и добавить некоторую дополнительную информацию в систему доказательств.

Итак, нам нужно доказать, что наше псевдообязательство по выходу связано с нашим оригинальным обязательством по маске или по сумме, скрытой маской, или, простите, по маске, которую мы применили к этому обязательству. Это очень похоже на то, что мы делаем в случае с RingCT, где мы вычитаем и используем вычтенный компонент.

Но одна особенность этого уравнения заключается в том, что в данном случае Ai имеет доказательство диапазона, поскольку при создании UTXO их диапазон доказывается в рамках обычной процедуры построения транзакции. Таким образом, если мы произведём вычитание C минус Ai и подпишем результат вычитания, то мы будем знать, что вычитаемое значение X здесь - это именно та маска, которая была добавлена к нашему обязательству по сумме. И поэтому теперь нам нужно включить это значение X в наше зеркальное обязательство для доказательства ставки.

Теперь посмотрим, что мы имеем здесь. Итак, нам необходимо более сложное доказательство, позволяющее показать, что C′ является зеркальным обязательством. Поэтому мы используем так называемое «линейное составное доказательство», подробно описанное в соответствующем документе по Zarcanum.

Теперь мы можем создать провести доказательство ставки. Это очень похоже на то, что мы делали раньше, но теперь у нас есть маска X, скрывающая другие значения, чтобы верификатор не смог восстановить - а что я собственно ищу - не смог восстановить исходное обязательство по UTXO, по которому делается ставка. И поэтому, чтобы подобного не произошло, мы включаем дополнительную маску x′′.

_**Sowle:**_ Я немного продолжу по теме. Итак, в основном всё происходит именно так, как объяснил koe - в более сложных случаях, когда используется набор ложных выходов, нам нужно как-то скрыть это обязательство. Фактически здесь мы имеем ту же самую систему, почти ту же самую систему, что и в простейшем случае. Но теперь нам необходимо добавить дополнительную маску. В итоге мы получаем чуть более сложную систему, которая включает в себя все эти значения. Но смысл этой системы фактически тот же, что и в простейшем случае.

_**koe:**_ Да, теперь всё просто скрывается масками. И у нас появляется аналогичное уравнение, но теперь оно заканчивается не элементом тождества, а маской x′. И, полагаю, что на основе этого можно создать доказательство. Не так ли? Мы доказали, что значение F здесь является верным. Таким образом, мы делаем всё то же самое, о чём говорилось ранее, но теперь с использованием дополнительной маски, чтобы скрыть то, что мы делаем, не позволяя доказывающей стороне нарушить инвариантность системы, и получить то же самое неравенство.

Таким образом, в этой системе есть дополнительные сложности, которые будет проблематично рассмотреть в рамках этой презентации из-за большого количества нюансов. Ключевым моментом здесь является то, что в этом неравенстве... думаю, нужно вернуться ещё назад, всё верно... так вот, в этом равенстве мы раскрываем значение D - давайте посмотрим - и раскрывая D, зная, что ba составляет 64 бита, мы, по сути, раскрываем несколько бит информации о том, что зафиксировано в A, в обязательстве A по нашему UTXO. Таким образом, отправитель транзакции может выяснить значение A путём перебора различных значений ba, а поскольку размер ba равен всего 64 битам, для перебора возможных значений потребуется 63 бита... Извините, я пропустил этот шаг. Итак, значение f не может быть нулевым. Значит, нужно добавить значение, которое будет включать в себя ключ просмотра. Но опять же, угадав ba, можно методом перебора также получить и значение этой дополнительной маски, которая добавляется здесь, и о которой говорится в нашей работе. И, вычислив это значение методом перебора, отправитель транзакции, просматривающий блокчейн и отслеживающий ставки, может восстановить ключ просмотра того, кто сделал ставку. Поэтому нами были предусмотрены способы защиты от этого, в том числе увеличение значения ba до 128 бит путём включения множителя.

_**Sowle:**_ По сути, мы нашли способ, как сделать этот вектор атаки более сложным, то есть, ощутимо повысить уровень его сложности. Способ описан в нашей белой книге, но по понятным причинам, мы не станем подробно рассказывать о нём в рамках этого выступления.

_**koe:**_ Да, я перечитывал документ неделю назад и заново открыл для себя эту проблему, забыв, что мы её уже решили. Поэтому меня действительно впечатляет, как нам удалось собрать воедино все эти доказательства и произвести все корректировки, необходимые для создания приватного доказательства ставки.

У нас есть ещё слайды? Да, есть. Ты хотел бы сказать об этом?

_**Sowle:**_ Да. Это довольно краткий слайд, на котором показано, сколько битов и байтов требуется, чтобы включить все эти изменения в систему доказательства ставки, которая уже реализована в Zano. И здесь можно увидеть, что, как уже упоминалось, мы «используем полнофункциональный вариант Zarcanum», где слово «полнофункциональный» означает, что мы включили все эти дополнительные возможности, которые делают атаку методом грубого перебора очень сложной. Также мы нашли, то есть, koe нашёл способ, как избежать нарушения анонимности отправителя-получателя, что было возможно в исходном подходе, продемонстрированном ранее, и он нашёл хитрый способ, как избежать этого. Но, к сожалению, решение этой проблемы обойдётся в 32 байта, добавляемые к каждому выходу. Но это вовсе не обязательно, поскольку в рамках некоторых решений анонимность отправителя-получателя обеспечивается иными способами. Например, Элис получает какие-то средства от Боба, и перед тем, как создать доказательство ставки по этим средствам, по выходам, чтобы создать новые блоки по схеме доказательства ставки, она сначала отправляет эти выходы самой себе и делает ставку уже только после выполнения этой процедуры. В некоторых случаях это может быть неудобно, поэтому в нашей работе мы предложили способ, позволяющий избежать всего этого. Здесь мы задействуем полнофункциональный вариант Zarcanum с применением Bulletproofs+ для доказательства диапазона и фактически получаем 64 умноженные на n плюс 896 байт на подпись и один групповой элемент на выход.

_**Модератор:**_ Пожалуй, уже можно перейти к вопросам.

_**Sowle:**_ Да, спасибо.

_**Модератор:**_ Может, нам подготовить следующие слайды? Отлично. Есть ли у кого-то в зале вопросы? Можете подойти? Рубен.

_**Вопрос из зала:**_ Хотелось бы задать вопрос - что маловероятно, но всё же, если Monero перейдёт к использованию схемы доказательства ставки, можно ли её будет использовать в предложенном виде или схему придётся сильно модифицировать? В частности, применительно к Seraphis.

_**Вопрос из зала:**_ Хороший вопрос.

_**koe:**_ Да, Думаю, они будут совместимы. Я мысленно произвёл кое-какие расчёты. Да, это возможно.

_**Вопрос из зала:**_ У меня вопрос - схема уже была где-то опубликована или рецензирована?

_**Sowle:**_ Она была опубликована на IACR 20 или 21 ноября, по-моему. В общем-то, она прошла рецензирование - мы получили отзыв от доктора Саранга по этому поводу. Так что, возможно, нам потребуется ещё несколько экспертных оценок. Но на данный момент мы считаем, что это достаточно простая конструкция, и мы стараемся охватить все возможности, ответить на все вопросы, которые возникают. Как я уже говорил, на данный момент эта конструкция уже реализована в Zano, но не в основной сети, а пока что, начиная с ноября, она работает в тестовой сети. Прежде чем запустить её в основной сети, мы хотим убедиться, что всё работает достаточно хорошо.

_**Вопрос из зала:**_ Спасибо.

_**Модератор:**_ Ещё вопросы? Можете подойти?

_**Вопрос из зала:**_ Оказывает ли это какое-либо влияние на возможность проверки на инфляционный баг?

_**Sowle:**_ Прошу прощения, вы имеете в виду...

_**Вопрос из зала:**_ [...]

_**Sowle:**_ Итак, вопрос состоит в том, поможет ли данное решение защититься от инфляционной атаки? Это сложный вопрос. Я думаю, что суть этого решения состоит в том, чтобы обеспечить соблюдение условия, чтобы это можно было доказать с нулевым разглашением. И основная трудность в нашем случае заключалась в том, чтобы доказать неравенство, используя стандартные криптографические элементы. Поэтому, как только схема консенсуса и схема эмиссии позволят создавать в блоках, вычисляемых по схеме доказательства ставки, ограниченное количество монет, все остальные части этой схемы, на мой взгляд, не будут способствовать какой-либо инфляции. При этом, находясь здесь, на сцене, и глядя в потолок, я не вижу, как это можно было бы сделать. Но, может быть, нам нужно больше...

_**koe:**_ Этого нельзя сделать. Если бы соответствие условию можно было бы подделать, любой смог бы его выполнить, независимо от того, какой суммой он при этом располагал бы. Полагаю, тогда можно было бы создавать блоки по схеме доказательства ставки очень быстро, буквально каждую эпоху. Таким образом, как только по схеме доказательства ставки создавался бы один блок, тут же можно было бы создавать следующий, потому что путём подтверждения неравенства соблюдалось бы соответствие условию. Таким образом, исключить подобную ситуацию позволит только правильное математическое решение.

_**Sowle:**_ Я хотел бы добавить, что если такое и случится, то, во-первых, в блокчейне будет видно, что количество блоков, созданных по схеме оказательства ставки, значительно увеличилось, и в то же время, как в случае с Zano, где мы используем гибридный консенсус, если кто-то найдёт способ, позволяющий без труда создавать блоки по схеме доказательства ставки, это не будет чем-то радикальным, например, для Zano. Но если решение будет реализовано исключительно как модель доказательства ставки, возможно, это будет иметь некоторые последствия. Поэтому с этим нужно быть осторожнее, как и с доказательством ставки в принципе.

_**Модератор:**_ К сожалению, у нас закончилось время. Давайте поаплодируем команде Zano. Спасибо, ребята.
