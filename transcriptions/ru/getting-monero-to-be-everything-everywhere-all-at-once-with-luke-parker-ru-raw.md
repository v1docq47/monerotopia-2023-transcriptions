# Люк Паркер

_**Как сделать Monero всем, везде и сразу**_

[https://youtu.be/2MgWx1Fpht4](https://youtu.be/2MgWx1Fpht4)

---

_**Люк:**_ Привет всем, меня зовут Люк Паркер. Моё сегодняшнее выступление называется «Как сделать Monero всем, везде и сразу». Нет, я не смотрел этот фильм и не стану распространяться на эту тему. Но для начала, немного о себе. Итак, меня зовут Люк Паркер, вы можете знать меня как Kayaba, или же, в Twitter или в IRC, как kayabaNerve. Оказывается, не только я смотрел аниме, когда был подростком, поэтом и другие тоже выбирают себе ник kayaba. Я являюсь разработчиком и неофициальным криптографом. Да, в области криптографии я могу всем вам надрать зад, но при этом я не могу провести аудит Bulletproofs.

Немного истории: мною был реализован первый атомный своп Monero. Так что я уже несколько лет интересуюсь технологиями, не требующими доверительных настроек, децентрализованными биржами и технологиями обеспечения приватности. В настоящее время я являюсь ведущим разработчиком Serai. Serai - это моя собственная децентрализованная биржа, о которой я немного расскажу в конце презентации. Но если кратко, мы пытаемся создать высоколиквидный AMM для Monero, сохранив при этом децентрализованность и безопасность. Также я являюсь членом комитета фонда Magic Monero. Magic - это благотворительная организация, и если вы являетесь гражданином США, не особо стремитесь лишний раз платить очередной налог и хотите сделать пожертвование в пользу Monero, обращайтесь к нам, мы с радостью примем ваши средства. Мы финансируем разработку Monero, мы финансировали несколько проектов в прошлом, мы также финансировали реализацию атомных свопов Ethereum-Monero, о которых мы поговорим позже. И, наконец, я упомяну об этом по просьбе Джастина Бермана, я действительно хорош в Тетрисе. И если кто-то тут хочет посоревноваться со мной, то я готов.

Итак, речь пойдёт не о повышении осведомлённости людей о Monero, а о расширении интеграции Monero. Итак, мы поговорим о программном обеспечении кошелька Monero и его множественных недостатках. Но если мы учтём все эти недостатки, если мы напишем собственное программное обеспечение кошелька, если мы займёмся собственной разработкой - при этом, чтобы понять то, о чём здесь будет говориться, вам вовсе не обязательно быть разработчиком - но если мы начнём рассматривать все возможные варианты преодоления сложностей и более широкого внедрения Monero, в результате которого к Monero станут привыкать - это приведёт к тому, что всё большее количество людей станет пользоваться Monero.

Отчасти эта презентация также является демонстрацией моей собственной работы, Monero Serai. Serai - это децентрализованная биржа, которая требовала реализации множества функций кошелька, которых у официального кошелька Monero попросту не было. Поэтому, поскольку необходимые функции у кошелька отсутствовали, мы в значительной степени переделали его. И я буду много говорить о Monero Serai, и честно предупреждаю об этом заранее. Но я также коснусь и нескольких других вариантов реализации кошелька, которые были разработаны за эти годы.

Итак, начнём с протокола кошелька Monero. Транзакции Monero подтверждаются на основе консенсуса. Вы не можете просто совершить транзакцию, сказав: «Дайте мне один миллион Monero». Monero - это не только протокол консенсуса, использующий кольцевые подписи и доказательства Bulletproofs. Это ещё и скрытые адреса. При этом в блокчейне скрытые адреса никак не проверяются. Безусловно, факт использования скрытого адреса фиксируется в блокчейне, но блокчейн Monero понятия не имеет, что это за адрес. Поэтому адрес Monero работает просто: я получаю адрес от своего кошелька и отправляю его на ваш кошелёк, а ваш кошелёк интерпретирует этот скрытый адрес надлежащим образом. Это один из примеров работы протокола кошелька Monero. Когда ваш кошелёк получает скрытый адрес и собирается отправить его, он производит ряд вычислений и генерирует одноразовый ключ. А затем мой кошелёк, а затем… извините, я немного путаюсь в словах. Если вы отправляете мне средства, то мой кошелёк сканирует блокчейн, производит те же самые математические операции со скрытыми адресами и смотрит, были ли эти одноразовые ключи направлены на мой адрес. И если да, то я говорю: «Всё отлично, я получил средства». Так работает протокол кошелька Monero.

Самое интересное заключается в том, что, несмотря на то, что предполагается, что все кошельки будут использовать единый протокол, мы всё же можем делать всё, что нам заблагорассудится. Вместо того чтобы использовать скрытые адреса, мы можем придумать свои собственные адреса и пользоваться ими. Возможно, этого и не стоит делать. Скрытые адреса - это отличное решение. Тем не менее, мы можем сделать это. И в случае с Jamtis, новой схемой адресации, которую предлагается реализовать вместе с Seraphis, стоит упомянуть, что эта схема была предложена в качестве альтернативной схемы адресации для текущей версии Monero, и была включена в обновление Seraphis. И хотя в рамках этой презентации я не собираюсь говорить о Jamtis, у меня есть несколько собственных схем адресации, которые я хотел бы обсудить.

Итак, по сути, протокол кошелька Monero даёт кошелькам полную свободу - они могут делать с ним всё, что пожелают. И теперь возникает вопрос: почему мы должны отказаться от протокола Monero? Почему мы должны идти своим путём? На это есть множество причин. Даже если вы неотступно следуете протоколу кошелька Monero, возможно, имеет смысл написать собственный вариант реализации кошелька. Просто потому, что в основном протокол Monero написан на C++. Я знаю многих, кто отказывается даже прикасаться к C++. Первая реализация атомных свопов Monero была написана на Rust, проект Farcaster был написан на Rust, а недавний форк Ethereum был написан на Go. Ни один из этих проектов не использует C++. Все они производят много кода, как и Monero. И интегрировать Monero в них довольно хлопотно. Поэтому если бы у нас были библиотеки Rust, если бы у нас были библиотеки Go, если бы у нас были библиотеки JavaScript, это бы значительно упростило разработку и позволило бы людям создавать больше приложений, расширило бы возможности интеграции и так далее.

Другая причина заключается в том, что Monero - большой проект. Если мы хотим внести изменения, они должны пройти рецензирование. И это хорошо. Мы не хотим, чтобы в Monero вносились какие-то случайные изменения, которые могли бы что-то нарушить, или чтобы создавались протоколы, от которых приходилось бы избавляться уже через месяц. Но в то же самое время это, возможно, сдерживает инновации. Поэтому, при наличии альтернативных вариантов реализации кошельков мы получаем возможность экспериментировать, идти своим путем, и они будут существовать ровно столько, сколько им и положено, а если они будут работать достаточно хорошо, мы даже сможем интегрировать их обратно в Monero.

Ещё одно преимущество состоит в том, что существующему кошельку Monero уже несколько лет, и он не рассчитан на полный срок жизни RingCT. Поэтому, если бы кто-то взглянул на него сейчас, то сказал бы: «Вот так и должен быть построен кошелёк». Но wallet2, текущая версия кошелька Monero, представляет собой некую сборную солянку из того, чем хотелось бы его сделать, а не из того, чем он должен быть на самом деле.

И последняя причина - создание более надёжной экосистемы. Ранее в кошельке wallet2 присутствовали ошибки, наиболее известная из которых - баг сжигания. Баг сжигания, по сути, является ошибкой в протоколе кошелька Monero, который косвенно определяет wallet2 как официальный кошелёк Monero. При наличии большего количества кошельков мы можем писать код, защищённый от ошибок, связанных с конкретными кошельками. И хотя, опять же, баг сжигания был связан с протоколом, и, возможно, его бы и не удалось обнаружить, в любом проекте также могут присутствовать и другие ошибки. Так что чем больше кода и чем больше альтернатив, тем только лучше.

А теперь предельно честный слайд, который меня заставил включить в презентацию мой друг Rucknium - почему это все плохая идея и полный отстой в принципе.

Внятной документации по протоколу кошелька Monero не существует. Наиболее информативной работой, пожалуй. будет книга «Monero с нуля», написанная koe, который сидит там сзади. И я не хочу сказать ничего плохого, но должен констатировать, что это очень, очень длинный PDF. И мне кажется, что многое в протоколе кошелька можно было бы упростить и представить куда более наглядно.

Если вы напишете свой собственный кошелёк и он будет создавать транзакции с хоть немного более высоким уровнем сложности, это нарушит приватность. Не только ваших собственных транзакций, но и в некоторой степени приватность всех остальных. В качестве примера можно взять MyMonero. В MyMonero одна функция, алгоритм выбора ложных выходов, была реализована несколько иначе. И поэтому можно было определить, какие транзакции были созданы с помощью MyMonero, а какие официальным программным обеспечением. Собственно, это и было моим следующим пунктом: нужно реализовать идентичный алгоритм выбора ложных выходов. Такой алгоритм указывает на то, какие ещё выходы вы используете при создании кольца. Это отнюдь не просто, и, к сожалению, в моей собственной работе это реализовано не совсем правильно, но у меня есть козёл отпущения. Джастин Берман обещал сделать всё в течение прошлого месяца, но так и не сделал, так что во всём виноват он.

И, наконец, всё это попросту требует поддержки и сопровождения. Monero - это большой проект, который продолжает расти. Мы ожидаем обновления Seraphis, и когда оно состоится, все мои труды пойдут прахом. Видимо, это даст достаточно преимуществ, и всё же я решил это сделать.

Итак, чтобы официально перейти к wallet2, напомню, что wallet2 - это официальная кодовая база кошелька Monero. Как уже было сказано, она написана на C++ и монолитна. Файл содержит 14 000 строк кода, и читать его не очень интересно. Я не встречал ни одного разработчика Monero, которому бы нравился код wallet2. Здесь присутствует несколько разработчиков кошельков. Ни один из них не сказал, что он им нравится. Они его «терпят». Просто он работает. Но он также определяет протокол кошелька Monero, официального кошелька Monero, и поддерживает все необходимые функции. Вы можете сканировать блокчейн на предмет получения средств, можете переводить Monero другим людям - старые добрые основные функции Monero. Он также поддерживает схему мультиподписи. И вот тут мы переходим к самой интересной части моей презентации.

Итак, он поддерживает схему мультиподписи и схему пороговой мультиподписи. Схема пороговой мультиподписи подразумевает, что при наличии пять человек, три из них смогут создать подпись и потратить Monero. Похоже, что математические расчёты на слайде, к сожалению, несколько исказились, но, по сути, это длинное математическое выражение с восклицательными знаками и есть сложность, это и есть время, которое потребуется для создания кошелька, поддерживающего схему пороговой мультиподписи. Это операция, известная как генерация ключей, и она может отличаться на единицу или около того, но в масштабе это не имеет значения. Так вот, если вы создаете мультиподпись по схеме 9 из 16, что составляет 51% от мультиподписи, состоящей из 16 участников, причём 16 - это максимальный размер, который официально поддерживается wallet2, то для этого потребуется 39 000 вычислений. И это вполне терпимо. Компьютеры сейчас достаточно быстры. Это вполне доступно, но не оптимально. Собственно, с этого и началась моя работа над Monero Serai.

Поскольку следующая часть выступления будет посвящена мультиподписи, а я также выступал на эту тему в прошлом году на MoneroKon, отмечу, что я очень увлечён этой темой. Если вас беспокоит возможность преждевременного ухода в мир иной и вы хотите, чтобы ваша семья могла восстановить ваши ключи, но не хотите своей матери или сестре мнемонической фразы, вы можете передать им её часть, чтобы они, достигнув обоюдного согласия относительно вашей смерти - мне бы, например, не хотелось, чтобы моя сестра просто стащила мои деньги, как она делала это достаточно часто в детстве - чтобы они таким образом смогли получить доступ к моему кошельку и восстановить средства. Но эта схема работает и в случае с корпорациями, если вы являетесь биржей и не хотите чтобы всё пошло по сценарию QuadrigaCX, то есть, чтобы в случае смерти генерального директора были потеряны все средства. Также это работает, если вы не хотите, чтобы у вас были хищения уровня FTX. Хотя, конечно, в случае с FTX всё было организовано, и это не помогло.

Поэтому в качестве строительного блока Serai, моего собственного проекта децентрализованной биржи, вместо того, чтобы взять за основу механизм проведения атомных свопов, при работе над UX мы пошли по пути использования мультиподписи. Фактически мы говорим о мультиподписи, построенной по схеме «67 из 100». То есть, у нас будет примерно 100 валидаторов, это наша цель, и 67 из них должны объединиться, чтобы завладеть средствами. И если они сделают это, будучи достаточно обеспеченными экономически, потеряют так много денег, что красть средства станет просто невыгодно. А вот в случае с математической формулой, показанной на предыдущем слайде, в случае с этим чудовищем, если бы мы захотели создать мультиподпись по схеме «67 из 100», то это потребовало бы один октиллион операций, то есть миллиард миллиардов, миллиардов вычислений. Существующие компьютеры быстры, но не настолько. Также полагаю, что получившийся файл кошелька занял бы петабайты. Так что нет.

Таким образом, поскольку такая мультиподпись просто не подошла в моём случае, я начал работу над Monero Serai. Проект написан на Rust, так что если у кого-то здесь есть хороший код, написанный на Rust, то да, вы можете просто взять собственную библиотеку, написанную на Rust, для работы с Monero. Код также поддерживает сканирование, отправку, получение и так далее, и тому подобное. А ещё он содержит гораздо более эффективную операцию создания мультиподписи. Если мы создадим мультиподпись по схеме «67 из 100», то для этого потребуется всего 6700 вычислений, в то время как даже создания мультиподписи по схеме «9 из 16» в случае wallet2 потребовалось бы 39 000 операций. Таким образом, даже при гораздо большем размере мультиподписи мы работаем гораздо эффективнее. И Monero Serai продолжила работу по реализации ещё нескольких улучшений протокола кошелька, которые в дальнейшем будут использованы для разработки всё большего количества приложений. Итак, я рассказал, как мультиподпись создаётся в Serai, и мы переходим к следующему пункту.

Nostr. Итак, Nostr стал популярен после того, как Twitter был продан Элону Маску. Многие адепты Bitcoin сказали: «А давайте просто создадим собственный Twitter». И это достойно уважения. Без сомнения, нужно создавать больше протоколов социальных сетей. И одна из вещей, которую он поддерживает - это zaps. Если вам нравится твит, если вы считаете, что кто-то публикует отличный контент, вы можете посредством Lightning перевести автору микроплатёж. И я это поддерживаю. Я не вижу ничего плохого в микроплатежах. И это породило множество дискуссий в сообществе Monero. Как можно задействовать Monero применительно к zaps? Можно долго обсуждать, нужно ли нам это, почему мы хотим этого, и как отреагирует сообщество Nostr? И я здесь, чтобы сказать: мне всё равно. Я знаю, как это сделать технически. И громогласно заявляю об этом. И если вы, ребята, действительно хотите использовать Monero в Nostr, вы должны заявить об этом. Здесь присутствует человек в очень красивой цветастой рубашке, Джастин Эренхофер, он обещал реализовать любую функцию Nostr, о которой его попросят на Monerotopia. По юридическим причинам это была шутка.

Таким образом, в рамках zaps всё все видят. Вы можете увидеть, сколько получило то или иное «событие» Nostr - так формально называются их твиты - событие, и вы можете увидеть, сколько получило событие Nostr. И, вы можете сказать: «Ого, людям очень нравится это событие. Они перевели целый Bitcoin». Или же «Вот как, никто не захотел переводить деньги за это событие. Оно никому не нравится». Так вот, в Monero для этого существует криптографическое доказательство. Оно называется OutProof. OutProof служит для того, чтобы сказать: «Да, я совершил транзакцию Monero, и в этой транзакции Monero я перевёл на этот адрес такую-то сумму».

И здесь возникают две проблемы. Во-первых, имеется техническая уязвимость к багу сжигания. Об этом вкратце говорилось в предыдущем выступлении. Баг сжигания заключается в том, что вы создаёте два выхода, которые имеют общий одноразовый ключ. А поскольку они используют один ключ, то и образ ключа у них будет общим. Таким образом, у вас будет два выхода с одним образом ключа, а образ ключа может существовать в блокчейне в единственном экземпляре. Соответственно, вы не можете потратить оба выхода. Можно потратить только один из них, и как только он будет потрачен, второй тут же будет сожжён. Вот, если кратко, в чём суть бага сжигания.

Доказательство OutProof подтверждает, что при проведении транзакции такой-то человек получил такую-то сумму, но не гарантирует, что одноразовый ключ не был использован повторно, потому что не обладает достаточным объёмом данных - не охватывает всего блокчейна, не охватывает всей сети. Это доказательство просто подтверждает перевод средств конкретному человеку в конкретной транзакции. Поэтому доказательства OutProofs требуют обмена дополнительной информацией. Это не самый технически эффективный вариант, и технически это решение не является полным.

И это подводит нас к очень сложной теме, которую я постараюсь максимально упростить. Речь пойдёт о «ключах просмотра исходящих транзакций честного отправителя». Честный отправитель... прошу прощения. Если я отправляю кому-то средства, то благодаря ключам просмотра исходящих транзакций я смогу увидеть, что было отправлено. В случае с Seraphis предлагается использовать ключи просмотра исходящих транзакций, которые будут демонстрировать только то, что ваши средства были потрачены. Они ничего не скажут о том, кому эти средства были отправлены. В рамках данного выступления ключи просмотра исходящих транзакций определяются гораздо более расплывчато. Они могут использоваться для чего угодно: от возможности увидеть, что ваши средства были потрачены, до возможности подтвердить, что на конкретные адреса действительно были перечислены средства в транзакции с таким ключом.

В настоящее время Monero не использует ключей просмотра исходящих транзакций. И если я совершаю платёж, я не могу сказать, что я его действительно совершил, не имея ключа траты. В идеале, для того, чтобы увидеть, что платёж был совершён, должно быть достаточно ключа просмотра. А в некоторых случаях, в идеале, при наличии одного только ключа просмотра, можно было бы сказать, что платёж был совершён, и средства поступили на указанный адрес.

Несмотря на отсутствие официальных ключей просмотра исходящих транзакций, мы можем задавать их. Это означает, что если отправитель согласится на их использование, если человек, создающий транзакцию, скажет: «Да, я хочу, чтобы эта транзакция была видна тому, у кого есть ключ просмотра исходящих транзакций», то тот, у кого есть ключ просмотра исходящих транзакций, сможет её просканировать. Это не безопасно с криптографической точки зрения, поскольку, если отправитель решит не сообщать о том, что он совершает транзакцию, никто не узнает, что он совершил её, что нарушает некоторые протоколы. Но в данном случае, в случае Nostr, когда кто-то проводит микроплатёж, делает пожертвование, по сути, за твит, это работает. Если вы хотите перевести кому-то небольшую сумму на Nostr, вы просто задаёте ключ просмотра исходящих транзакций Nostr. И тогда любой сможет увидеть в блокчейне соответствующие транзакции, воспользовавшись ключом просмотра Nostr. И увидев такие транзакции, сможет сказать: «Это был перевод за событие Nostr». А затем найти само событие Nostr, и сказать: «Да, за это событие были переведены средства». Это тоже будет абсолютно безопасно. Вы сможете подтвердить, что за событие Nostr действительно были получены средства, и какая именно сумма была получена.

Это безопасней, чем текущее предложение Lightning, потому что текущее предложение Lightning или текущее предложение по улучшению Lightning основано на доверии. Любой может сказать: «Я бы хотел отправить тебе деньги», и получить ответ: «Да, я получил такую-то сумму денег». Насколько я могу судить, вы можете солгать и указать любую сумму. Можно создать событие Nostr, которое получит 30 миллионов Bitcoin. Так что, этот вариант действительно немного безопасней.

Кроме того, такие ключи имеют и другие применения. Они также могут использоваться для защиты транзакций, построенных по схеме мультиподписи. И это одна из причин, почему я так рад появлению Seraphis. При создании транзакции по схеме «3 из 5», безусловно, трём подписантам будет известно, что они подписали транзакцию, поскольку они участвовали в подписании. Но два других подписанта не будут знать, что транзакция была подписана - их попросту не было в момент подписания. Таким образом, до тех пор, пока три участника мультиподписи будут честны, ключ просмотра исходящих транзакций честного отправителя позволит двум другим подписантам в конечном итоге понять, что транзакция, попавшая в блокчейн, была создана ими. Что они приняли участие в её создании.

Таким образом, ключ может быть использован для защиты мультиподписи, и это именно то, что требуется Serai, поскольку биржа предполагает её использование. Поэтому в Monero Serai реализованы ключи просмотра исходящих транзакций честного отправителя. Мы не поддерживаим их в том виде, в котором это было бы необходимо для Nostr, но если кто-то интересуется Nostr и хочет обсудить этот вопрос, я буду рад. И ещё раз, просто чтобы напомнить: Seraphis поддерживает ключи просмотра исходящих транзакций, что необходимо для многих протоколов.

Собственно, это всё, что касается Nostr. Но есть и другой пример того, что можно сделать с Monero, если немного доработать протокол. Самую малость. Ещё одним примером является Molly. Возможно, этот слайд несколько маловат - извините, если так. Molly - это форк Signal, но при этом является полностью открытым вариантом программного обеспечения и не содержит проприетарного кода. Лично я пользуюсь этим инструментом и рекомендую его всем остальным. И в CCS был создан запрос на интеграцию Monero. Он появился спустя какое-то время после того, как Signal создали MobileCoin. И в Molly  тоже захотели создать собственную криптовалюту, но им не очень нравилась MobileCoin. И задумались над реализацией Monero.

В итоге разработчики Molly занялись созданием Monero SDK для Android. У них есть приложение для Android, и они хотят поддерживать Monero. Интеграция с wallet2 не показалась им целесообразной. Одна из причин заключается в том, что wallet2 написан на C++, а C++ не считается безопасным языком с точки зрения памяти, что очень важно. 70% всех проблем Microsoft, связанных с безопасностью, относились к проблемам с памятью. Поэтому использование в Microsoft языка, безопасного для памяти, позволило бы автоматически решить 70% проблем безопасности. Но, к сожалению, wallet2 написан на языке C++, который не является таковым. Не хочу сказать, что разработчиков не особо волнует данный вопрос при использовании этого языка, но у разработчиков Molly всё же были опасения на этот счёт.

Кроме того, в wallet2 была напрямую реализована возможность организации сети. И если я правильно понимаю, разработчики Molly хотели убедиться в том, что даже DNS-запросы будут проходить через Tor или любой другой указанный прокси, и сомневались, способен ли wallet2 на это. И, наконец, в wallet2 некоторые записи журналов шифровались не сразу. А позиция Molly в отношении обеспечения приватности и безопасности состоит в том, чтобы в том случае, если бы что-то было сделано, это было бы зашифровано, и только пользователь бы знал, что что-то было сделано.

Таким образом, разработчиками Molly фактически был создан SDK для Android. Он был построен на базе wallet2, но они избавились от многих элементов кода верхнего уровня и покопались в его внутренностях. Свой Android SDK они полностью интегрировали с Android Studio. Они создали «песочницу» C++, и если возникают проблемы с памятью, это ограничиваются только кодом wallet2, и не касается приложения Molly или всей остальной системы.

Ими также была реализована возможность организации сети со стороны клиента. То есть вместо того, чтобы осуществлять маршрутизацию через wallet2, который также является клиентским, вместо того, чтобы делать это через библиотеку wallet2, они дают возможность самостоятельной организации сети. Это даёт гораздо больше гибкости, гораздо больше контроля, а также позволяет производить балансировку нагрузки на стороне клиента, что должно давать более высокую производительность при синхронизации, сканировании транзакций, отправке и так далее и тому подобное. И, наконец, на уровне приложений был повышен уровень приватности, например, было введено шифрование всех записей журнала. Таким образом, даже если я украду ваш телефон, я не смогу заполучить данные журнала, которые скажут мне, что происходило с вашими Monero.

И как бы последний урок из всего этого - нам нужно гибкое, настраиваемое, управляемое программное обеспечение для кошельков. Если кто-то захочет отключить журнал, у него должна быть такая возможность. Уверен, в случае с wallet2 имеется нужный оператор. Я не хочу как-то принизить wallet2, и не утверждаю, что сам могу сделать это. Я просто пытаюсь отметить, как все эти составляющие могли бы работать вместе, а также говорю о необходимости разумного дизайна. Организация сети с помощью wallet2 - да, со слов разработчиков Molly, это не было чем-то привнесённым исключительно извне, и это было областью, требующей улучшения.

Всё это понемногу уводит нас в строну сетевой составляющей вопроса. Большинство кошельков подключаются к сети через стандартные соединения - HTTP или, если вы хотите обеспечить безопасность, HTTPS. Пользователи, которых заботит собственная приватность, используют Tor. Другие пользователи, которым также не безразлична их приватность, используют I2P, особенно учитывая недавние DDoS-атаки на Tor. Так что да, людям действительно необходимо, чтобы приложение предлагало выбор: возможность использования I2P, использования Tor, или даже стандартного сетевого соединения. И уж точно никто не хочет слепо доверять библиотеке, если только она явно не может обеспечить этого, не обеспечивает API и не делает этого чисто.

С другой стороны, когда мы начинаем обсуждать этот вопрос, речь идёт о работе в браузере. Существует множество глупых причин использовать Monero в качестве сетевого кошелька, однако для этого есть и много совсем неглупых причин. Но если вы работаете в браузере, вы не можете подключиться к Tor. Вы не можете подключиться к I2P. Вы даже не можете делать стандартные сетевые запросы. Буквально ничего из этого не доступно. Приходится делать специфические для браузера сетевые запросы через JavaScript. Теперь вопрос в том, как заставить код на C++ генерировать сетевые запросы через JavaScript? И это отдельный и очень длинный разговор, равно как и о том, почему не стоит ожидать, что возможность организации сети будет доступна при использовании любой библиотеки, которая когда-либо будет написана.

И я знаю, что сейчас обсуждается множество вопросов, связанных с новым кошельком Seraphis, его дизайном, но на данный момент я сосредоточен на существующей сегодня версии программного обеспечения нашего кошелька и его текущих возможностях.

Поэтому, если вы хотите написать собственный неткод, вам придётся докопаться до самых внутренностей wallet2 и переписать большую его часть. Именно так поступили разработчики Molly. В моём случае, в случае Monero Serai, я просто позволяю пользователю выбрать любое сетевое соединение. Это означает, что пользователь сам и сразу может указать сетевое соединение Tor, указать I2P, может указать какой-то специфический для браузера сетевой протокол, может воспользоваться голубиной почтой. Я просто стараюсь обеспечить максимальную гибкость.

Ещё одним примером использования специализированного программного обеспечения кошельков являются аппаратные кошельки. В настоящее время Monero поддерживается платформами Ledger и Trezor, и ни одна из них не использует wallet2. Обе платформы используют собственные варианты реализации протокола кошелька Monero. И я бы сказал, что это связано с тем, что написание собственных библиотек Monero разработчики сочли более целесообразным, нежели использование wallet2 для их построения. И я не говорю, что они не правы. Я говорю, что они написали тысячи строк кода только для того, чтобы не иметь дело с wallet2 на своих устройствах. И это вполне разумно. Аппаратные кошельки очень ограничены в ресурсах. У них очень медленные процессоры, очень ограниченный объём памяти, в то время как wallet2, как предполагается, был создан, чтобы запускаться на стационарных компьютерах, ноутбуках и даже на телефонах. Но телефоны всё равно обладают на много порядков большей вычислительной мощностью, чем аппаратный кошелек. Поэтому вполне логично, что wallet2 оказался нереализуемым. Но в то же время очень жаль, что случилось именно так.

Таким образом, разработчики Ledger использовали C++, а разработчики Trezor - Python. Сейчас также разговоры идут о работе с Foundation’s Passport. Это ещё один аппаратный кошелек. Они также хотят реализовать поддержку Monero. Поэтому сейчас и обсуждается, что с ним делать. Возможно, в итоге они поступят, как команда Trezor, потому что у них также много кода написано на Python, и они смогут легко реализовать подобный вариант.

Но, не буду врать, лично я продвигаю Monero Serai из личных пристрастий. Я знаю код, я с ним работал, я ему доверяю. Если я и буду работать с чем-то в Monero, то предпочту использовать собственные наработки. Но в то же время это просто грамотно построенная библиотека кошелька. Она проходит тщательное тестирование, и я надеюсь, что в течение нескольких месяцев будет проведён ее аудит. И тот факт, что в случае Monero Serai вообще позволяет построить её, наглядно демонстрирует, что таки да, можно разработать библиотеку кошелька, или, в данном случае, библиотеку транзакций, способную работать в больших масштабах. То есть. что её можно будет использовать в работе целой децентрализованной биржи. Да, сейчас мы обсуждаем возможность её использования с аппаратным кошельком, а затем, мне кажется, будет рассматриваться и возможность её интеграции в Stack Wallet. Так что, безусловно, мы вполне способны создавать более продуманные кошельки или просто кошельки, адаптированные под конкретные варианты использования.

И теперь я покажу вам то, о чём только что рассказывал. wallet2 не создавался изначально с учётом возможности использования с аппаратными кошельками. И ситуация не меняется. Аппаратные кошельки принимают транзакции Monero, не имеющие подписи и известные как «неподписанные транзакции», и создают для них свои собственные подписи. Формат неподписанных транзакций определяет wallet2 в случае с холодными кошельками. Он не самый лучший. Уверен, найдутся те, кто скажет: «А мне нравится формат неподписанных транзакций wallet2. Он работает». Но он просто берёт все внутренние переменные wallet2, сохраняет их в файл и на этом всё заканчивается. И это работает, если вы используете wallet2. Но если вы не используете wallet2, вам придётся в точности воспроизвести все переменные wallet2 и обработать данные, чтобы добиться желаемого результата. А некоторые из этих данных разработаны не самым безопасным образом. Я мог бы говорить об этом ещё дольше, но постараюсь быть кратким. В общем, на мой взгляд, формат неподписанных транзакций wallet2 не рассчитан на производительность. И не только на производительность. Я сомневаюсь в том, что он рассчитан для критичных с точки зрения безопасности  вариантов использования. Я не говорю, что он совершенно небезопасен. Я хочу сказать, что его можно было бы доработать так, чтобы он стал более безопасным.

Итак, разработчики кошельков могут либо реализовать протокол с учётом его недостатков, либо разработать свой собственный. А в случае с форком Foundation Passport, ориентированном на Monero, в настоящее время обсуждается «минимальный» формат неподписанных транзакций, который будет отличаться высокой производительностью, низкими затратами на передачу данных и повышенным вниманием к безопасности. Он не позволяет вредоносному компьютеру отправлять данные, которых там быть не должно. Поэтому я очень надеюсь, что это направление продолжит развиваться само и вносить свой вклад в общее развитие. Изначально я говорил: да, если мы создадим альтернативные кошельки, у нас будет возможность выработать альтернативные варианты реализации и построить лучшие протоколы. Но конечная цель всегда должна состоять в улучшении сообщества Monero в целом. Не для того, чтобы можно было сделать форк и создать какую-то собственную монету, а для того, чтобы сделать Monero более доступным и более функциональным проектом.

Я уже не раз упоминал о баге сжигания, даже, пожалуй, чаще, чем следовало, но да, он позволяет отправлять Monero, которые, по сути, нельзя потратить. На самом деле всё очень непросто, потому что в оригинальной версии баг сжигания означал, что вы могли отправить Monero один раз, а затем отправить те же Monero повторно, но их уже было бы нельзя потратить. Поэтому было неважно, кто спровоцировал баг сжигания, потому что человек, совершивший обе транзакции, оказывался злоумышленником. А если один и тот же человек совершает обе транзакции и является злоумышленником, то он точно им и является, и его можно просто выкинуть из системы, и дело с концом.

К сожалению, воспользоваться багом сжигания может не только злоумышленник. Если вы публикуете свой ключ просмотра, если вы благотворительная организация, если вы просто хотите пройти аудит, если вы находитесь на втором уровне, на котором публикуются собственные данные о транзакциях, любой пользователь сможет воспользоваться багом сжигания, чтобы навредить любому другому пользователю. И поскольку любой пользователь может воспользоваться багом против любого другого пользователя, вы не сможете определить, какая именно транзакция была вредоносной. Потому что если Элис захочет отправить средства, а затем зайду я и проведу свою транзакцию, и моя транзакция окажется первой в блоке, протокол увидит сначала мою транзакцию, а потом уже транзакцию Элис. И протокол решит, что Элис является злоумышленником, повторно использовавшим одноразовым ключом, в то время как на самом деле это было сделано мой исключительно для того, чтобы подставить Элис. И существуют варианты, ряд нюансов, благодаря которым злоумышленник не потеряет никаких денег, но другие пользователи при этом не досчитаются значительных средств. Так что баг сжигания определённо вызывает беспокойство, потому что подобное может произойти не только в том случае, если вы были оригинальным отправителем, но даже если у вас просто есть ключ просмотра.

Это также чревато последствиями для кошельков, предназначенных исключительно для просмотра, которые не позволяют определить момент проведения транзакций. А поскольку они не могут сделать этого, они не будут знать, были средства сожжены или нет. Потому что средства фактически сгорают, когда тратится один единственный выход.

Предлагаемый мной формат «функциональных» адресов не предполагает сравнения с Jamtis. Он создавался в виду фактического отсутствия Jamtis и необходимости в какой-то конкретной функции, под которую можно  было бы написать спецификацию и увидеть, что из этого выйдет. Такие адреса защищены от бага сжигания. Кроме того, они обладают большей функциональностью. Я знаю одного человека, который хотел иметь подадрес, но также хотел при этом использовать идентификатор платежа вместе с этим подадресом. Когда подадреса были добавлены в протокол Monero, мы тем самым как бы сказали: «Зачем нам использовать идентификатор платежа вместе с подадресом? Подадрес сам по себе является идентификатором платежа». Но всё же был такой случай, и поэтому я добавил такую возможность, поскольку специальные его поддержку, поскольку функциональные адреса тем и интересны. Что предлагают различные функции.

Но главное - они могут быть устойчивы к багу сжигания. А если они устойчивы к сжиганию, то это не только позволяет создавать гораздо более безопасные кошельки просмотра, но и значительно упрощает многие аспекты разработки протоколов более высокого уровня. В моём случае протокол более высокого уровня - это протокол децентрализованной биржи, но это может быть и множество других структур. Это могут быть атомные свопы, платёжные каналы, всё, что вы захотите сделать с Monero, и так далее, и так далее. Опять же, это будет включено в Seraphis, но я слишком нетерпелив, и хочу заполучить все эти функции прямо сейчас.

Выбор языка - и это то, о чём я уже говорил ранее - wallet2 написан на C++. Одна из неприятных особенностей языка C++ заключается в  отсутствии стандартизированной системы сборки. Поэтому многие используют CMake и Make, которые являются стандартными инструментами сборки. CMake и Make работают под Windows. Насклолько мне известно, технически они работают. Но их очень трудно заставить работать под Windows. Итак, поскольку C++ не предполагает стандартизированной системы сборки, и поскольку мы используем стандартные средства сборки, но даже работа со стандартными средствами сборки может быть сложной, даже простая сборка wallet2 с целью интеграции может вызвать большие затруднения. Я знаю нескольких человек, которые в настоящее время всячески пытаются собрать его под Windows для последующего распространения, но пока не добились успеха. И даже если вы знакомы с CMake и Make и можете ими воспользоваться, сценарии сборки включают в себя сотни строк и совершенно мне не нравятся. На самом деле, строк могут быть тысячи.

Поэтому, хоть вы и можете вызывать wallet2 из C++, поскольку он сам написан на C++, если вы захотите вызывать его из любого другого языка, вам придётся писать привязки. Привязки - это маленькие кусочки кода, которые говорят: «Так, ты написан на JavaScript, ты - на C, ты - на Go, а мне нужен C++». Но если бы у вас была библиотека, написанная на «родном» языке, если бы у вас была библиотека Go для Go, если бы у вас была библиотека Rust для Rust, вам бы не потребовалась дополнительная сборка, вам бы не понадобились дополнительные привязки, вы могли бы просто взять библиотеку и пользоваться ею. Это самый бесшовный способ разработки из всех возможных.

И, наконец, ещё раз отмечу, что C++ не является безопасным для памяти. 70% проблем безопасности Microsoft связаны с безопасностью памяти. А вот Rust и Python, на которых написаны библиотеки транзакций Monero, являются безопасными для памяти языками. При этом я сейчас не говорю, что что протокол Monero небезопасен для памяти. Я не хочу сказать, что не следует использовать wallet2. Я хочу лишь сказать, что если вы не хотите беспокоиться об этом классе ошибок, то можете воспользоваться доступными альтернативами.

И, наконец, как я пообещал Дагу, в конце я скажу пару слов о Serai. Мы действительно используем большинство из упомянутых здесь протоколов. Мы не просто хватаемся за всё, что можно было бы круто реализовать. Нет. Но это вещи, которые сегодня действительно необходимы в разработке для целого ряда протоколов. Serai - лишь один из них.

Итак, что такое Serai. В основе Serai лежит децентрализованная схема мультиподписи с финансовыми обязательствами. Поэтому любой может стать участником схемы мультиподписи Serai. Мы не говорим: «Так, они применяют KYC, эта компания, зарегистрирована на Каймановых островах». Нет. Если вы внесёте финансовый залог, вы сможете стать членом схемы мультиподписи, а если вы будете плохо себя вести, мы заберём ваш финансовый залог. Безусловно, если в сговоре с вами будет большинство участников, то да, вы сможете украсть все Monero, а мы просто возьмём ваши Serai и выкупим Monero.

На начальном этапе мы ориентируемся на Bitcoin, Ether, DAI и Monero. DAI исключительно как средство приближения расчётов к доллару США. И мы действительно используем ключи просмотра исходящих транзакций честного отправителя только для того, чтобы определить, когда участники мультиподписи совершили транзакцию. Потому что требуем, чтобы только две трети сторон проводили транзакцию, а другая треть оставалась как бы в неведении. И ключи просмотра исходящих транзакций честного отправителя позволяют оставшейся трети участников сказать: «Да, транзакция была совершена. Она была проведена, как и ожидалось, и мы можем продолжать».

Мы также используем функциональные адреса, позволяющие избежать бага сжигания. Если бы нам пришлось столкнуться с данным багом, один пользователь мог бы сказать: «Слушай, поменяй мои 100 Monero на Bitcoin». И затем другой пользователь также мог сказать: «Обменяй мои 100 Monero на Bitcoin». Но только в одном из этих случаев средства могли бы быть потрачены. И поскольку только один из этих выходов Monero мог бы быть потрачен, только один из них был бы признан действительным. Таким образом, один пользователь получил бы своё, а другой полностью потерял свои средства. Вот почему этот баг в нашем случае очень опасен, и почему нам так нужны функциональные адреса, устойчивые к багу сжигания. В том числе для того, чтобы наконец был реализован Seraphis.

Да, и все это действительно необходимо для того, чтобы правильно построить децентрализованную биржу для Monero. Проделана большая работа. Я потратил четыре-пять месяцев только на работу с Monero.

Проект Serai разрабатывается уже более года. Скоро он будет реализован в прототипе сети, нашей собственной тестовой сети. Базовая функциональность состоит в нашей способности работать с Bitcoin и Monero. Мы можем подключаться к одноранговой сети и подписывать данные. У нас есть блокчейн, где мы можем размещать представления Bitcoin и Monero, а затем с помощью прототипа сети мы сможем обмениваться ими внутри сети и создавать дополнительные варианты интеграции, кошельки и сервисы.

_[Реклама]_

_Вы любите кофе и Monero так же сильно, как и мы? А вам не хотелось бы начинать каждый свой день с чашки Gratuitas? Покупайте зёрна премиум-класса за Monero, и если вам придётся по душе их вкус, поделитесь цифровыми чаевыми непосредственно с гватемальскими фермерами, которые позаботились о вас. Ваша поддержка способствует развитию нашего предприятия. Gratuitas и Monero._

**Приносим извинения за сбой в работе и потерю контента, вызванные неожиданным отключением электроэнергии. Благодарим Вас за понимание!**

_**Люк:**_ ...и вы не можете определить, кто платит за услуги, а кто просто совершает обычную транзакцию. Итак, Monero действительно может включать поддельный идентификатор платежа, но только если у вас два выхода. Если у вас больше двух выходов, это не важно. Не знаю, почему было введено это правило, но оно было введено, и я всегда случайно включал идентификатор платежа. Технически я уверен, что это верно, если вы отправляете на адрес, соответствующий идентификатору платежа, и если у вас 10 выходов. Monero будет включать идентификатор платежа, но моё поведение было несколько иным, и это, вероятно, позволяет проводить статистический анализ, что снижает уровень приватности. Так что в случае с Monero всё нужно делать точно, а это очень непросто. В алгоритме выбора ложных выходов я реализовал код, который мне прислали, и сказали, что он правильный, и я думал, что реализовал его правильно. Но я реализовал его неправильно. Мы выбрали 16 выходов, и 12 из них были coinbase-выходами. Предполагается, что благодаря P2Pool у нас должно быть внушительное количество coinbase-выходов. Но мы не предполагали, что у нас их будет 12. Значит, тут есть какая-то ошибка, хотя мне казалось, что я всё сделал правильно и даже вроде бы знал все соответствующие правила протокола.

Поэтому основная проблема заключается не в создании кошелька Monero. Она заключается в создании кошелька Monero, который был бы точно таким же, как Monero. Но я надеюсь, что по мере появления более чистых кошельков, будь то Monero, Serai или новый кошелёк Seraphis - koe проделал огромную работу, чтобы убедиться, что он будет чистым, правильным, удобочитаемым и так далее и тому подобное. Я надеюсь, что всё больше и больше людей станет разбираться во всех тонкостях и сможет создавать собственное программное обеспечение. Также надеюсь, что им не придётся создавать программы с нуля, а они просто будут использовать уже готовые и реализовывать форки.

_**Вопрос из зала:**_ [...]

_**Люк:**_ Вовсе нет. Я просто отмечаю, что это должен быть гораздо более чистый код, чтобы, когда мы его реализуем, у нас было бы меньше всех этих случайных странностей, которые нам затем придётся выискивать в кодовой базе Monero. Я думаю, что роль двух выходов определяется библиотекой TXutils на базе CryptoNote, а не какими-нибудь файлами кошелька, потому что я не знаю, кто организовал папку CryptoNote. Ну, технически я думаю, что они здесь присутствуют, но это уже другая тема. Ещё вопросы? Можете задать ещё один.

_**Вопрос из зала:**_ Тот же вопрос я задал на предыдущей презентации. После выполнения столь амбициозного проекта, что посоветуете разработчикам?

_**Люк:**_ Это займёт больше месяца. Стоп, стоп, стоп. Я сказал три месяца. Когда мы встречались, я сказал три месяца, Джастин. Я превышаю срок на 400% или 300%, а не на 1100 или 1000, неважно, на 1100.

Ладно, шутки в сторону. Либо у вас должен быть человек, действительно увлечённый проектом, готовый работать бесплатно. В идеале - несколько человек, действительно увлечённых делом и готовых работать бесплатно. Я как-то обманул Джастина Бермана, чтобы он согласился решить мои проблемы с Monero, но это было не бесплатно. Не смог обратить его в свою веру. В общем, надеюсь, у вас есть несколько человек, готовых работать бесплатно, но если у вас их нет, то нужно просто найти людей, которые действительно знают, что делают, не просто думают, что знают, а действительно знают, что делают, и не только делают, а делают максимально осознанно. Но при этом у вас должна быть «взлётная полоса», чтобы поддерживать их не только до запуска проекта, но и в случае, если ваш проект выйдет за рамки бюджета и придётся выполнять больше работы и делать больше разных вещей. Я уверен, что у Джастина Эренхофера есть своя история, и есть свои клиенты Nostr, о которых он когда-нибудь расскажет, но я оставлю это на будущее. В общем, либо ищите либо очень увлечённых, либо очень состоятельных лохов. Я почему-то изначально потановил, что у нас не будет никакого премайна, никаких отчислений и выплат разработчикам и никакого ICO, и в результате потратил кучу денег. Так вот.

_**Люк:**_ Лично я считаю, что это должно быть совершенно произвольное поле. Сейчас Monero помещает туда данные кошелька. Но я считаю, что там не должно быть никаких данных кошелька. Я считаю, что оно должно быть абсолютно опциональным. Переменной длины. Я не вижу необходимости в фиксированном размере, например, чтобы он составлял 256 байт. И потом, меня не волнует, будет оно зашифровано или нет. Если люди хотят добавить в него зашифрованный тест, я не против. Мне просто всё равно.

В идеале я бы хотел, чтобы поле осталось. Если его уберут, то технически у нас есть обходной путь, просто его реализация займёт пару месяцев. Кто-нибудь ещё?

_**Вопрос из зала:**_ [...]

_**Люк:**_ Если выбрать что-то одно, то моё главное разочарование связано с обилием комментаторов на GitHub, не имеющих ни малейшего представления о том, о чём они говорят. Я очень ценю то, что люди хотят внести свой вклад в развитие Monero. Они хотят, чтобы их голос был услышан, потому что разработчики проектов Monero существуют для того, чтобы служить сообществу. Если мы не будем служить сообществу Monero, тогда зачем мы пишем код? В этом нет никакого смысла. На самом деле это было в духе... Нет, не буду рассказывать эту историю. Я должен оставаться поборником приватности.

Главное, что меня расстроило - это то, что когда члены сообщества всё же заходили в тему на GitHub и оставляли свои комментарии, потому что хотели быть услышанными, хотели убедиться, что всё делается в духе Monero, они либо просто повторяли то, что уже было сказано, либо просто не понимали технических аспектов. И они писали что-то вроде: «Меня беспокоит, дополнительное поле транзакции упростит анализ блокчейна». Но то, что они описывали, вовсе не требовало наличия дополнительного поля. Всё это было вполне возможно и без него. Так что это просто показало, что есть много членов сообщества, которые действительно увлечены Monero, что замечательно, но, к сожалению, они рассуждают на темы, в которых не разбираются, и меня волнует тот факт, что всё это размывает общее понимание проблемы. Поэтому, хотя у меня и нет решения, потому что единственное решение в этом случае - это какие-то тесты эффективности, что является полной чушью. И как вообще можно создать закрытое сообщества? То есть, хотя я и поощряю участие сообщества, я призываю членов сообщества задавать вопросы в IRC, а уж потом делать какие-то заявления.

Если это всё, то я с радостью передам микрофон и вернусь на своё место. Отлично. Спасибо всем за внимание.
